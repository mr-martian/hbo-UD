DELIMITERS = "<sb>" ;

####################
# Boundaries
####################

LIST PB = pb ;
LIST CB = cb ;
LIST SB = sb ;
LIST BD = pb cb sb ;
LIST Sent = ("׃" punct) ("נ" punct) ("פ" punct) ("ס" punct) ;
SET BDsent = BD OR Sent ;

####################
# POS
####################

LIST Det = art ;
LIST Pr = prep ;
LIST Joiner = ("׀" punct) ("־" punct) ;
SET NonJoiner = (*) - Joiner ;
LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;
LIST RelMark = ("אשׁר" conj @mark) ("ה" conj CP Rela) ;
LIST Number = card ordn ;
LIST PRON = prde prps prn ;
LIST ADJ = adjv ;
LIST ADV = advb nega ;

####################
# Text-Fabric labels
####################

# Complete

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;
LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ
LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;
LIST Domain = N D Q ? ;

# Subsets

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;
LIST VerbInitial = Way0 WayX ;
LIST NonQuote = N D ? ;

####################
# Helper labels
####################

LIST HasConj = HasConj ;

LIST PPHead = PPHead ;
LIST NPHead = NPHead ;

LIST MaybeClauseRoot = MaybeClauseRoot ; # could be root of some clause
LIST ClauseRoot = ClauseRoot ; # is root of clause
LIST FullClauseRoot = FullClauseRoot ; # is root of non-relative clause
LIST TopClauseRoot = TopClauseRoot ; # is root of non-quoted clause

####################
# Universal Dependencies
####################

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound = @compound ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @flat = @flat ;
LIST @dep = @dep ;       # Any remaining dependency

########################################
# INDIVIDUAL WORDS
########################################

BEFORE-SECTIONS

####################
# Corrections
####################

LIST MislabeledAsNarrative = w1404 w1405 w1423 w1424 w14251 w14252 w14253 ;
SUBSTITUTE (N) (Q) MislabeledAsNarrative ;

####################
# Retagging
####################

# Substantivized adjectives
SUBSTITUTE (adjv) (subs retag:adjv) (c) ;
SUBSTITUTE (adjv) (subs retag:adjv) (a) (1 BD) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv a) (1 (prn)) ;
# TODO: does this really apply to all gentillics?
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl pl) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (NEGATE 0* (subs) OR (nmpr) BARRIER PB) ;

# Participles in smixut
LIST Participle = ptca ptcp ;
LIST NPish = NP PP ;
SUBSTITUTE (verb) (subs retag:verb) Participle + NPish ;

# Adverbs tagged subs
SUBSTITUTE (subs) (advb retag:subs) (padv) (-1 BD) (1 BD) ;

# Determiner on clause participles
SUBSTITUTE (art) (conj retag:art) (CP Rela) ;

####################
# Consistent labels
####################

MAP @punct (punct) ;
MAP @det Det ;
MAP @case Pr ;
LIST SCONJ = "כי" "פן" "אשׁר" "אם" "שׁ" "ה" ; # TODO: double check שׁ which only appears once
MAP @mark SCONJ + (conj CP) ;
MAP @mark ("ה" inrg) ;
MAP @cc (conj) - (Rela) ;
MAP @advmod ADV ;
MAP @advmod ("למה" inrg) ;
MAP @discourse (intj) ; # TODO: is there a better way to handle הנה?

####################
# Pronoun suffixes
####################

SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;

########################################
# PHRASES
########################################

SECTION

####################
# Pronoun suffixes
####################

MAP @nsubj (prn PreS) ;
MAP @obj (prn PreO) ;
MAP @obj (prn) IF (-1 (verb)) ;
SETPARENT (prn @obj) OR (prn @nsubj) (NOT p (*)) TO (-1 (verb)) ;
MAP @nmod:poss (prn) IF (-1 Noun - (verb) - Number) ;
SETPARENT @nmod:poss (NOT p (*)) TO (-1 Noun) ;

####################
# Numbers
####################

LIST BigNumber = "עשׂרה" "מאה" "עשׂר" ;
MAP @flat BigNumber + Number IF (-1* Number BARRIER NonJoiner) ;
SETPARENT @flat + Number (NOT p (*)) TO (-1* Number BARRIER NonJoiner) ;
MAP @conj Number IF (-1* @cc BARRIER NonJoiner LINK -1* Number BARRIER NonJoiner - @flat) ;
SETPARENT @cc (NOT p (*)) TO (1 Number + @conj) ;
SETPARENT Number (NOT p (*)) TO (1 (prn)) ;
SETPARENT Number + @conj (NOT p (*))
    TO (-1* Number - @flat BARRIER NonJoiner - @cc - @flat) ;
SETPARENT Number + (c) (NOT p (*)) TO (1* Noun - Number BARRIER NonJoiner - Det) ;
SETPARENT Number (NOT p (*)) TO (-1 Noun - Number) ;
SETPARENT Number (NOT p (*))
    TO (1* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
SETPARENT Number (NOT p (*))
    TO (0* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
MAP @nummod Number IF (p Noun OR (prn)) ;

####################
# Smixut
####################

MAP @compound:smixut Noun IF (-1* Noun + (c) - @nummod BARRIER NonJoiner - Det - @nummod) ;
SETPARENT @compound:smixut (NOT p (*)) TO (-1* Noun) ;

####################
# Determiners
####################

SET DetAble = Noun OR ADJ OR PRON ;
SETPARENT Det (NOT p (*)) TO (1 DetAble) ;
LIST PrnMaybeDet = prde (prps p3) ;
MAP @det PrnMaybeDet IF (-1 Det LINK -1* Noun BARRIER NonJoiner) ;
SETPARENT @det (NOT p (*)) TO (-1* Noun BARRIER NonJoiner - Det) ;

####################
# Adjectives
####################

SET AdjNonBar = NonJoiner - (nega) ;
SETPARENT (nega) (NOT p (*)) TO (1* ADJ BARRIER NonJoiner) ;
MAP @conj ADJ IF (-1* @cc BARRIER AdjNonBar LINK -1* ADJ BARRIER AdjNonBar) ;
MAP @conj ADJ IF (-1* ADJ BARRIER AdjNonBar)
                 (1* @cc BARRIER AdjNonBar LINK 1* ADJ BARRIER AdjNonBar) ;
SETPARENT ADJ + @conj (NOT p (*))
    TO (-1* ADJ - @conj BARRIER AdjNonBar - @cc) ;
SETPARENT @cc (NOT p (*)) (-1* ADJ BARRIER NonJoiner) TO (1* ADJ BARRIER AdjNonBar) ;

SETPARENT ADJ + $$AGen + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$AGen + $$ANum + $$ADet BARRIER PB OR Pr) ;
SETPARENT ADJ + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$ANum + $$ADet - AGen BARRIER PB OR Pr) ;
MAP @amod ADJ IF (p Noun) ;

####################
# Prepositions
####################

LIST CaseAbleAdv = "כן" "שׁם" "פה" "שׁם" "הלאה" ;
SET CaseAble = Noun - @nummod - @flat OR PRON OR (verb infc) OR (verb infa) OR CaseAbleAdv + ADV OR (prin) OR (inrg);
SET AfterPrep = Det OR @case OR @nummod OR Number + @compound ;
SETPARENT @case (NOT p (*)) TO (1* CaseAble BARRIER NonJoiner - AfterPrep) ;
SETPARENT @case (NOT p (*)) TO (1*A ADJ BARRIER NonJoiner - AfterPrep LINK NOT p (*)) ;

####################
# Label NP heads
####################

LIST etNotAcc = w3165 ;
ADD PPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead) (c @case - ("את") OR etNotAcc) ;
ADD NPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead OR NPHead) ;

####################
# NP/PP conjunctions
####################

SETPARENT REPEAT @cc (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;
ADD REPEAT HasConj NPHead OR PPHead IF (NOT 0 HasConj) (c @cc) ;

####################
# Apposition
####################

MAP @appos NPHead - HasConj - (nmpr) IF (-1* NPHead OR PPHead BARRIER BD) ;
LIST Titles = "בכר" ;
MAP @appos NPHead - HasConj + (nmpr) IF (-1* NPHead + Titles BARRIER BD OR NPHead OR PPHead) ;

####################
# Connect NPs
####################

SET NonAppos = NPHead - @appos ;

MAP REPEAT @conj PPHead + HasConj IF (-1* PPHead BARRIER BD OR NonAppos) ;
MAP REPEAT @conj PPHead IF (-1* PPHead BARRIER BD OR NonAppos)
                           (1* PPHead + HasConj BARRIER BD OR NonAppos) ;

SECTION
SETPARENT PPHead + @conj (NOT p (*))
    TO (-1* PPHead - @conj BARRIER BD OR NonAppos) ;

SECTION
LIST ApposOverride = (w93 Ruth) ;
LIST ConjToAppos = w36714 (w7950 Exodus) (w95 Ruth) ;
MAP @appos ApposOverride;
SETPARENT CaseAble + ConjToAppos TO (-1* @appos) ;
MAP @conj NPHead + HasConj IF (-1* NonAppos BARRIER BD) ;
MAP @conj NPHead IF (-1* NonAppos BARRIER BD) (1* NPHead + HasConj BARRIER BD) ;
SETPARENT NPHead + @conj (NOT p (*)) TO (-1* NonAppos - @conj BARRIER BD) ;

LIST Family = "בן" "בת" "אב" ;
SETPARENT Family + (subs) (NOT p (*)) TO (-1 (nmpr a)) ;

LIST ApposToLastGen = w11294 w12466 w12610 w12711 w13874 w14590 w14649 w18761 w18788 ;
LIST ApposToLastRut = w19 w93 ;
SET ApposToLast = ApposToLastGen + (Genesis) OR ApposToLastRut + (Ruth) ;
SETPARENT CaseAble + ApposToLast (NOT p (*)) TO (-1 (subs) OR (nmpr) OR (prn)) ;
SETPARENT CaseAble - ApposToLast - ConjToAppos (NOT p (*))
     TO (-1* BD LINK 1*A CaseAble - @compound:smixut BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @appos CaseAble IF (p CaseAble) ;

SETPARENT PPHead (NOT p (*)) TO (-1* NPHead BARRIER PB) ;
MAP @nmod PPHead IF (p NPHead) ;

####################
# Other labels
####################

MAP @cop (vbcp) IF (0* (PreC) BARRIER CB) ;

SECTION # helper labels

LIST CanAddMaybeClauseRoot = PreC Pred PreO ;
LIST CannotAddMaybeClauseRoot = @cop MaybeClauseRoot @nummod ;
ADD MaybeClauseRoot CanAddMaybeClauseRoot - CannotAddMaybeClauseRoot ;

SECTION # adjacent words

# TODO: should probably retag in this case, but to what?
LIST DetIshAdv = "גם" "רק" focp  ;
SETPARENT DetIshAdv + @advmod (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;

LIST SmallQstQ = inrg prin ;
LIST SmallQstPrn = prde prn ;
MAP @nsubj SmallQstQ IF (-1 BD) (1* SmallQstPrn BARRIER NonJoiner LINK 1 BDsent) ;
SETPARENT SmallQstQ + @nsubj TO (1* SmallQstPrn BARRIER NonJoiner) ;
ADD MaybeClauseRoot SmallQstPrn - MaybeClauseRoot IF (c @nsubj) ;

SECTION # phrase-internal structure

ADD (ClauseRoot) (adjv AjCl) - (ClauseRoot) IF (NOT p (*)) ;

SECTION

MAP @obl Noun + (Adju a) ;

SET NonNmCl = (*) - (NmCl) - (prn) ;

MAP @acl (MaybeClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
SETPARENT (subs @acl) TO (-1* Noun - (NmCl) - (verb)) ;

SECTION

LIST SubjAble = subs prps nmpr prde prn ;

MAP @nsubj SubjAble + (Subj) ;

SETPARENT @cop TO (1* (MaybeClauseRoot PreC)) ;
SETPARENT @nsubj TO (1* (MaybeClauseRoot PreC) BARRIER CB) ;

SECTION # conjunction

SETPARENT (conj PP) (NOT p (*)) TO (1* (subs PP)) ;
MAP @conj (subs PP) - (PreC) IF (0 (subs) LINK c @cc) (NOT c @cop) ;
LIST CorC = (@conj) (@compound:smixut) ;
SETPARENT ("בין" subs PP @conj) TO (-1* ("בין" subs PP) - @conj) ;
SETPARENT (subs PP @conj) (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;
MAP @conj (subs NP) IF (0 (subs) LINK c @cc - (CP)) ;
SETPARENT (subs NP @conj) (NOT p (*)) TO (-1* (subs NP) - @conj - @compound:smixut) ;

SECTION

SETPARENT (conj CP) OR RelMark TO (1* MaybeClauseRoot) ;
MAP @acl MaybeClauseRoot IF (c RelMark) ;
LIST AclAble = subs adjv ptcp ptca ;
SETPARENT @acl TO (-1* CB LINK -1* AclAble BARRIER BD) ;
#LIST EXCB = excb ;
#SUBSTITUTE (cb) (excb) (cb) (0* @acl BARRIER CB OR EXCB) ;

MAP @advmod (verb infa) IF (1 PB) (2 (verb)) ;
SETPARENT (verb @advmod) (NOT p (*)) TO (2 (verb)) ;

SECTION

LIST ObjAble = subs prn nmpr prin prde ;

ADD (ProbablyObj) ObjAble + (Objc) - (ProbablyObj) ;

SECTION

LIST Ptc = ptcp ptca infc ;

SETPARENT (verb) + Ptc (NOT p (*)) TO (-1* Noun - @compound:smixut BARRIER NonJoiner - BD - @det - @compound:smixut) ;
MAP @acl (verb) + Ptc IF (p Noun) ;

SECTION

MAP @xcomp (ProbablyObj) IF (-1* (ProbablyObj) BARRIER (verb MaybeClauseRoot)) ;
MAP @obj (ProbablyObj) IF (NOT -1* (ProbablyObj) BARRIER (verb MaybeClauseRoot)) ;

ADD (PrepVerb) (verb) - (PrepVerb) IF (c @case) ;

SECTION

MAP @ccomp ("אמר" verb infc) ;
MAP @advcl (MaybeClauseRoot Q) IF (c @mark) (1* (MaybeClauseRoot Q) BARRIER NonQuote LINK NEGATE c @mark) ;
MAP (ClauseRoot @ccomp) (subs MaybeClauseRoot) IF (c (vbcp infc Pred)) (NOT -1* @ccomp) ;
MAP @conj (MaybeClauseRoot Q) IF (c @cc) (-1* (MaybeClauseRoot Q) - @acl - @advcl BARRIER (N)) ;
MAP @parataxis (MaybeClauseRoot Q) - (infc) IF (NEGATE c @cc) (NEGATE c @mark) (-1* (MaybeClauseRoot Q) - @acl - @advcl BARRIER (N)) ;
MAP @ccomp (MaybeClauseRoot Q) IF (NEGATE c @mark) (-1* MaybeClauseRoot + NonQuote) (NOT -1* (MaybeClauseRoot Q) - @acl BARRIER (N)) ;
LIST CRconj = @ccomp @root @parataxis ;
SETPARENT (MaybeClauseRoot Q @conj) (NOT p (*))
    TO (-1* (MaybeClauseRoot Q) + CRconj) ;
MAP @root MaybeClauseRoot IF (NOT -1* MaybeClauseRoot - @advcl) ;

LIST PostAdvcl = (w948 Ruth) (w1301 Ruth) ;
SETPARENT @advcl + PostAdvcl (NOT p (*)) TO (-1* MaybeClauseRoot) ;
SETPARENT @advcl (NOT p (*)) TO (1* MaybeClauseRoot) ;

SETPARENT (@ccomp Q) OR ("אמר" verb infc) (NOT p (*)) TO (-1* (quot MaybeClauseRoot)) ;
LIST CcompAble = "חלל" "נתן" "מהר" "צוה" "שׁמע" ;
SETPARENT @ccomp (NOT p (*)) TO (-1* CcompAble + MaybeClauseRoot) ;
LIST SpeakingVerb = quot "ברך" "צוה" ;
SETPARENT ("אמר" infc @ccomp) (NOT p (*)) (c ("ל" prep)) TO (-1* SpeakingVerb) ;

LIST XcompVerb = "ראה" "ירא" "נחם" "שׁחת" "קרא" "מלא" "לבשׁ" "שׁחת" "נגד" "ידע" "מהר" "פקד" "יכל" ;
LIST AdvclAble = ("כי" conj @mark) ("אם" conj @mark) ;
LIST ActuallyCcomp = (w351 Genesis) ;
SETPARENT MaybeClauseRoot + $$Domain (c AdvclAble) (NOT p (*))
    TO (-1* MaybeClauseRoot + $$Domain BARRIER Domain - $$Domain) ;
SETPARENT (verb infc) + $$Domain (NEGATE c @cc) (NOT p (*))
    TO (-1* MaybeClauseRoot + $$Domain BARRIER Domain - $$Domain) ;
MAP @ccomp ActuallyCcomp ;
MAP @xcomp MaybeClauseRoot IF (c AdvclAble) (p XcompVerb) ;
MAP @advcl MaybeClauseRoot IF (c AdvclAble) (p (*)) ;
MAP @xcomp (PrepVerb) IF (p XcompVerb) ;
MAP @advcl (PrepVerb) IF (p (*)) ;

MAP @conj (PrepVerb) IF (-1* (PrepVerb) BARRIER ClauseRoot) (c @cc) ;
SETPARENT (PrepVerb) + @conj (NOT p (*)) TO (-1* (PrepVerb) - @conj BARRIER ClauseRoot) ;

LIST ClauseCon = @conj @parataxis @xcomp ;
MAP (@conj ClauseRoot) MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) MaybeClauseRoot + $$NonQuote - (PrepVerb) IF (-1* MaybeClauseRoot + $$NonQuote) ;

SETPARENT @obj (NOT p (*)) TO (0* (verb MaybeClauseRoot) BARRIER CB) ;
SETPARENT (@obj w107001) TO (-1* (w106997)) ; # why is there a CB in this verse?
SETPARENT @xcomp (NOT p (*)) TO (-1* (verb MaybeClauseRoot)) ;

LIST DontConj = @conj @acl @nmod @xcomp @appos @advcl @nmod:poss ;
SETPARENT MaybeClauseRoot + ClauseCon + $$Domain (NOT p (*)) TO (-1* MaybeClauseRoot + $$Domain - DontConj) ;

LIST OblIsh = Time Cmpl Loca ;
MAP @obl Noun + OblIsh ;

SETPARENT @advmod + VerbInitial (NOT p (*)) TO (-1* (verb MaybeClauseRoot)) ;
SETPARENT @advmod (NOT p (*)) TO (0* (verb MaybeClauseRoot) BARRIER CB) ;
SETPARENT (@advmod AjCl) (NOT p (*)) TO (0* (adjv) BARRIER CB) ;

SETPARENT @discourse TO (1* (ClauseRoot) BARRIER CB) ;

SECTION

MAP @dislocated Noun + (CPen) ;
SETPARENT (@dislocated Frnt) TO (1* MaybeClauseRoot) ;

SECTION

MAP @vocative Noun + (Voct) ;
LIST VerbArgs = @nsubj @obj @obl @vocative ;

MAP @obl (subs Adju) ;
MAP @obl (prn PP) IF (c @case - ("את")) ; # TODO: sometimes @nmod ?

SETPARENT VerbArgs (NOT p (*)) TO (0* (MaybeClauseRoot) BARRIER CB) ;
SETPARENT VerbArgs (NOT p (*)) TO (0* (verb) BARRIER CB) ;
SETPARENT (verb infc) (NOT p (*)) TO (-1* (subs c) BARRIER NonJoiner - BD) ;
MAP @acl (verb infc) IF (p (subs)) ;

SETPARENT VerbArgs (NOT p (*))
    TO (c @acl LINK 1* CB LINK 1* MaybeClauseRoot BARRIER CB) ;

SETPARENT @mark (NOT p (*)) TO (1* (ClauseRoot) OR MaybeClauseRoot) ;

SECTION

SETPARENT VerbArgs (NOT p (*)) TO (-1* CB LINK -1* @acl BARRIER CB LINK p (*)) ;

SETPARENT @root TO (@0 (*)) ;
SETPARENT Sent TO (-1* @root) ;
LIST PunctToPrev = prep conj (prin @nsubj) @discourse @advmod ;
LIST PunctToNext = @nsubj @advmod @compound:smixut @det @amod @flat @appos @acl ;
LIST PunctToParent = @mark @case @nummod @cc ;
LIST PunctTo2Parent = @nmod:poss ;
SETPARENT Joiner (NOT p (*)) TO (-1* PunctToPrev BARRIER (*) - BD) ;
SETPARENT Joiner (NOT p (*)) TO (1* PunctToNext BARRIER (*) - BD) ;
SETPARENT Joiner (NOT p (*)) TO (1* PunctToParent BARRIER (*) - BD LINK p (*)) ;
SETPARENT Joiner (NOT p (*)) TO (-1 @obj OR @nummod) ;
SETPARENT Joiner (NOT p (*)) TO (-1 PunctTo2Parent LINK p (*) LINK p (*)) ;

SETPARENT @vocative + (Q) (NOT p (*)) TO (0* MaybeClauseRoot + (Q)) ;
SETPARENT @vocative (NOT p (*)) TO (-1* ClauseRoot) ;
SETPARENT @vocative (NOT p (*)) TO (0* @root) ;

SETPARENT @discourse (NOT p (*)) TO (1* (verb) BARRIER (*) - BD) ;
SETPARENT @discourse (NOT p (*))
    TO (1 (prn)) ;
    # TO (1 (prn) LINK p (*)) ; # this one is probably more correct
                                # but we need some other rules first

AFTER-SECTIONS

UNMAP @nsubj IF (NOT p (*)) ;
MAP @dislocated SubjAble + (Subj) ;
SETPARENT @dislocated (NOT p (*)) TO (-1* ClauseRoot) ;

REMCOHORT (pb) ;
REMCOHORT (cb) ;
REMCOHORT (sb) ;
REMCOHORT (excb) ;

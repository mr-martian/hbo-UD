#!/usr/bin/env python3

import utils
import datetime

base_fields = [
    # (key, file, description, provenance)
    ('upos', 'upos', 'universal part-of-speech',
     'generated based on Sp and Ls features'),
    ('head', 'head', 'UD parent word',
     'generated by parser with input from MACULA and manual checking'),
    ('deprel', 'deprel', 'UD dependency relation',
     'generated by parser with input from MACULA and manual checking'),
    ('prs_head', 'prs_head', 'UD parent word of pronominal suffix',
     'generated by parser with input from MACULA and manual checking'),
    ('prs_deprel', 'prs_deprel',
     'UD dependency relation of pronominal suffix',
     'generated by parser with input from MACULA and manual checking'),
    ('LId[Strongs]', 'strongs', "Strong's number", 'from MACULA'),
    ('LId[SDBH]', 'sdbh', 'Semantic Dictionary of Biblical Hebrew ID',
     'from MACULA'),
    ('LexDomain[SDBH]', 'sdbh_dom',
     'Semantic Dictionary of Biblical Hebrew lexical domain',
     'from MACULA'),
    ('Ref[MACULA]', 'macula', 'MACULA ID number',
     'generated by alignment script'),
    ('prs_Ref[MACULA]', 'prs_macula',
     'MACULA ID number of pronominal suffix',
     'generated by alignment script'),
]

fields = {}

for key, fname, desc, prov in base_fields:
    f = open(f'bhsa-ud-tf/tf/2021/{fname}.tf', 'w')
    if key in ['head', 'prs_head']:
        f.write('@edge\n')
    else:
        f.write('@node\n')
    f.write('@author=Daniel Swanson\n')
    f.write('@coreData=BHSA\n')
    f.write('@description=' + desc + '\n')
    f.write('@provenance=' + prov + '\n')
    f.write('@valueType=str\n')
    f.write('@version=2021\n')
    f.write('@writtenBy=hbo-UD/export_tf.py\n')
    dt = datetime.datetime.now(datetime.UTC).replace(microsecond=0)
    dts = dt.isoformat().split('+')[0]+'Z'
    f.write('@dateWritten=' + dts + '\n\n')
    fields[key] = (f, 0)

def write_value(key, wid, value):
    global fields
    if key not in fields:
        return
    f, n = fields[key]
    nl = wid - n - 1
    if 0 <= nl < len(str(wid)) + 1:
        if key in ['head', 'prs_head'] and nl > 0:
            f.write(f'{wid}\t{value}\n')
        else:
            f.write('\n'*nl + str(value) + '\n')
    else:
        f.write(f'{wid}\t{value}\n')
    fields[key] = (f, wid)

for book, export in utils.load_book_data('Export').items():
    if export == 'No':
        continue
    for sid, block in utils.iter_conllu(f'data/checked/{book}.conllu'):
        last_wid = None
        idx2wid = {}
        heads = []
        prs_heads = []
        for row in utils.iter_words(block):
            if row[3] == 'PUNCT':
                continue
            if row[9] == '_':
                continue
            misc = dict([p.split('=') for p in row[9].split('|')])
            prefix = ''
            if 'Ref[BHSA]' not in misc:
                if row[4] == 'prn':
                    wid = last_wid
                    prefix = 'prs_'
                    prs_heads.append((row[0], row[6]))
                else:
                    continue
            else:
                wid = int(misc['Ref[BHSA]'])
                if wid == last_wid:
                    continue
                heads.append((row[0], row[6]))
            idx2wid[row[0]] = wid
            write_value(prefix+'upos', wid, row[3])
            write_value(prefix+'deprel', wid, row[7])
            for m, v in misc.items():
                write_value(prefix+m, wid, v)
            last_wid = wid
        for n, h in heads:
            ni = idx2wid.get(n)
            hi = idx2wid.get(h)
            if ni and hi:
                write_value('head', ni, hi)
        for n, h in prs_heads:
            ni = idx2wid.get(n)
            hi = idx2wid.get(h)
            if ni and hi:
                write_value('prs_head', ni, hi)

for f in fields:
    fields[f][0].close()

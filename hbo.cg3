DELIMITERS = "<svb>" ;

####################
# Boundaries
####################

LIST PB = pb ;
LIST CB = cb ;
LIST SB = sb ;
LIST SVB = svb ;
LIST BD = pb cb sb svb ;
LIST Sent = ("׃" punct) ("נ" punct) ("פ" punct) ("ס" punct) ;
SET BDsent = BD OR Sent ;
LIST Joiner = ("׀" punct) ("־" punct) ;
SET NonJoiner = (*) - Joiner ;

####################
# POS
####################

LIST Det = art ;
LIST Pr = prep ;
LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;
LIST RelMark = ("אשׁר" conj @mark) ("ה" conj CP Rela) ("שׁ" conj) ;
LIST Number = card ordn ;
LIST PRON = prde prps prn ;
LIST ADJ = adjv ;
LIST ADV = advb nega ;
LIST SCONJ = "כי" "פן" "אשׁר" "אם" "שׁ" "ה" "לולא" "לו" (conj retag:prep) ;
LIST NonMarkingSCONJ = "לו" ;

####################
# Subcategories
####################

LIST Participle = ptca ptcp ;

####################
# Text-Fabric labels
####################

# Complete

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;
LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ
LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;
LIST Domain = N D Q ? QQ ;
LIST Rela = rela:Adju rela:Attr rela:Cmpl rela:Coor rela:Objc rela:PrAd rela:PreC rela:ReVo rela:Resu rela:RgRc rela:Spec rela:Subj ;

# Subsets

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;
LIST VerbInitial = Way0 WayX ;
LIST NonQuote = N D ? ;
LIST RelaNonAcl = rela:Cmpl rela:Objc rela:PreC ;

####################
# Helper labels
####################

LIST HasConj = HasConj ;
LIST HasMark = HasMark ;
LIST HasRel = HasRel ;

LIST PPHead = PPHead ;
LIST NPHead = NPHead ;

LIST CR = ClauseRoot ;
LIST ClauseRoot = ClauseRoot ; # is root of clause
LIST FullClauseRoot = FullClauseRoot ; # is root of non-relative clause
LIST SR = SentenceRoot ;

SET PlainC = CR - HasMark - HasRel ;
SET PlainNC = PlainC - HasConj ;

LIST Lemma = ".*"r ;
LIST Lemma2 = ".*"r ;

LIST Q = Q ;
LIST QQ = QQ ;
LIST NQ = NQ ;
LIST QuoteLevel = NQ Q QQ ;

LIST VerbArgs = @nsubj @obj @obl @vocative (@xcomp adjv) (@advcl infa) (@advcl infc) @advmod ;

####################
# Word lists
####################

LIST NegObl = ("בלת" subs InfC) ;
LIST QMark = ("לאמר" SCONJ verb) ;

LIST CaseAbleAdv = "כן" "שׁם" "פה" "שׁם" "הלאה" "הנה" "עתה" "אז" "כה" ;

LIST FamilyOrTitle = "בן" "בת" "אב" "כלה" "אשׁה" "מלך" "גברת" "שׂר" "אחות" "כהן" "אח" ;

LIST CcompVerb = "ראה" "ירא" "ידע" "נחם" "נגד" ;
LIST XcompVerb = "שׁחת" "קרא" "מלא" "לבשׁ" "שׁחת" "מהר" "יכל" "חדל" "אמץ" "כלה" ;
LIST AdvclMarkVerb = "קרא" ;
LIST PrAdvcl = "עד" ;
LIST XcompInf = "יסף" "יכל" "חפץ" "מהר" "אמץ" "חדל" "כלה" "ירא" "מלא" "חלל" "קרב" "יאל" "לאה" "צוה" "נתן" ;

LIST SpeakingVerb = quot "ברך" "צוה" "נגד" "דבר" "ענה" "שׁמע" ;

LIST ConjAblePrep = "כמו" "למען" ;

LIST Masculine = "מכיר" ;

####################
# Special-case words
####################

LIST PPHeadOverride = (Ruth w575) (Ruth w580) ;

# Apposition and NP conjunction
LIST FamilyOrTitleSkip = (Genesis w14663) ;

LIST ApposToLastGen = w265 w297 w307 w640 w648 w734 w1129 w1257 w1338 w1966 w2993 w3000 w5450 w7733 w11294 w12466 w12610 w12711 w13874 w14590 w14649 w18761 w18788 w19072 w3308 w3314 w3331 w5402 w4106 w4185 w6817 w6820 w2672 w8520 w8578 w9563 w24352 w24349 w6459 w27627 w27629 w7423 w10681 ;
LIST ApposToLastRut = w19 w50 w93 w1528 ;
SET ApposToLast = ApposToLastGen + (Genesis) OR ApposToLastRut + (Ruth) ;

LIST ApposOverAcl = (Genesis w3325) (Genesis w12858) (Genesis w14778) (Genesis w10252) ;

LIST ApposOverride = (w93 Ruth) (w189 Genesis) (Genesis w14323) (Genesis w4544) ;
LIST ConjToAppos = w36714 (w7950 Exodus) (w95 Ruth) (w215 Genesis) (w313 Genesis) (Genesis w303) (Genesis w5424) (Genesis w6462) (Genesis w7517) (Genesis w7793) ;
LIST ConjToSmixut = (Genesis w734) (Genesis w6582) (Genesis w6628) (Genesis w8154) ;

# prn doesn't have w###, so use preceding prep
LIST PrnNmodToSublist = (Genesis w2960) (Genesis w3165) (Genesis w3871) (Genesis w3921) (Genesis w4172) (Genesis w3298) (Genesis w26108) ;

# @acl and @advcl
LIST NonAclOverride = (Genesis w2676) (Ruth w1682) ;

LIST MarkOverride = (Genesis w1508) (Genesis w1561) (Genesis w2064) (Genesis w2072) (Genesis w14455) (Genesis w15341) (Ruth w319) ;
LIST NonMarkOverride = (Genesis w1243) (Genesis w11173) ;
LIST NonRelOverride = (Genesis w2676) ;

LIST PreMark = (Genesis w1774) (Genesis w6030) (Genesis w6036) (Genesis w11906) (Genesis w16927) (Genesis w17650) (Genesis w28321) (Ruth w1212) (Ruth w1206) (Ruth w1412) (Genesis w6169) (Genesis w9388) (Genesis w8176) (Genesis w11268) (Genesis w25408) ;
LIST PostMark = (Genesis w1035) (Genesis w1231) (Genesis w2977) (Ruth w948) (Ruth w1301) (Ruth w1467) (Genesis w5736) (Genesis w17852) (Genesis w7273) (Genesis w8069) (Genesis w28587) (Genesis w17852) (Genesis w28587) ;
LIST NestMark = (Genesis w2099) (Genesis w2760) (Genesis w13723) (Genesis w16271) (Genesis prn c32626) (Genesis w21741) (Genesis w25551) (Ruth w122) (Ruth w127) (Ruth w266) (Ruth w1161) (Ruth w1181) (Ruth w1325) (Genesis w8239) ;
LIST MarkToAcl = (Genesis w1848) (Genesis w19068) (Genesis w26087) (Ruth w714) (Genesis w12378) (Genesis w5084) ;

LIST ActuallyCcomp = (w351 Genesis) (Genesis w1037) (Genesis w1251) (Genesis w7129) (Genesis w3697) ;
LIST ActuallyAdvcl = (Genesis w26044) (Genesis w28625) (Ruth w1161) (Ruth w1187) (Ruth w1418) (Genesis w8318) (Genesis w15305) (Genesis w7576) (Genesis w15883) (Genesis w25513) (Genesis w23318) (Genesis w23300) (Genesis w18024) (Genesis w9388) (Genesis w8176) (Genesis w9841) (Genesis w9928) (Genesis w13245) ;

LIST DontConjTo = (Genesis w4993) ;
LIST HasConjOverride = (Genesis w4584) ;

####################
# Universal Dependencies
####################

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound = @compound ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @flat = @flat ;
LIST @flat:name = @flat:name ;
LIST @orphan = @orphan ;
LIST @fixed = @fixed ;
LIST @dep = @dep ;       # Any remaining dependency

####################
# Special-case words
####################

LIST etNotAcc = NonAcc (Genesis w2857) (Genesis w2946) (Genesis w3165) (Genesis w3529) (Genesis w3560) (Genesis w3693) (Genesis w4172) (Genesis w4221) (Genesis w13880) (Ruth w897) (Ruth w901) (Genesis w25257) ;

####################
# Unsorted lists
####################

LIST NPish = NP PP ;
LIST SubsOverride = (Genesis w20500) (Ruth w1233) ; # actually nouns, don't retag as prep
LIST ItgAdv = "מתי" "איפה" "איך" "אן" "מדוע" ;
LIST VoctNonCROverride = (Genesis s81570) (Genesis s81725) (Genesis s85145) (Genesis s82809) (Genesis w9312) ;
LIST NsubjPrn = ExsS ModS NCoS PrcS PreS (InjP IntS ClausePhraseRoot) ;
LIST ObjPrn = PreO PtcO ;
LIST BigNumber = "עשׂרה" "מאה" "עשׂר" ;
LIST NumberedOverride = (Genesis w3094) ; # should have @nummod child but normally wouldn't
LIST PrnMaybeDet = prde (prps p3) ;
LIST BetterHeads = Pred Subj Objc PreC PreO ;
LIST AdvIsh = (advb AdvP) (nega NegP) ;
LIST NumberLabel = @nummod @conj @flat ;
LIST ConjHeadOverride = (Genesis w3284) (Genesis w3292) (Genesis w3327) (Genesis w4544) (Genesis w6216) ;
LIST NPIsh = NP PPrP PP PrNP PreO ;
LIST Titles = "בכר" ;
LIST Inf = (infc InfC) PrepVerb ;
LIST NmodOverridePrep = (Genesis w17245) (Genesis w15328) ; # prep whose prn should get @nmod
LIST ApposToConjHead = (Genesis w3289) (Genesis w3332) ;
LIST YesApposAble = subs nmpr prn (adjv NPHead) (adjv PPHead) ;
LIST NoApposAble = wp2 @nmod:poss ;
SET ApposAble = YesApposAble - NoApposAble ;
LIST NorP = NPHead PPHead ;
LIST CorC = (@conj) (@compound:smixut) ;
LIST ConjSkipClause = (Genesis w1771) (Genesis w11903) (Ruth w1409) (Genesis w9386) (Genesis w8174) (Genesis w6737) (Genesis w6738) ; # conjunction to clause after next clause
LIST NoGlom = prep ;
LIST SubjIsh = Subj (IntS prn) ;
LIST OblIsh = Time Cmpl Loca Modi Adju Supp (Conj PPHead) ;
LIST PredIsh = PreC PrcS PrAd PreO PreS PtcO ;
LIST CopIsh = (Pred vbcp) NCop NCoS ;
LIST NonCopIsh = (Genesis w1955) ;
LIST OrphanPrepVerb = (Genesis w18716) ;
LIST RelaCRToPrev = (Genesis w1037) (Ruth w1316) (Genesis w3697) (Genesis w6172) (Genesis w21741) (Genesis ph59024 ClauseRoot) ;
LIST ObjcXcomp = "יסף" "יכל" ;
LIST AdjuXcomp = "מהר" "נתן" ("אמץ" hit) "חדל" "צוה" "כלה" "חפץ" "יסף" "חלל" "קרב" "ירא" "מלא" "לאה" "יאל" "אבה" ;
LIST Ptc = ptcp ptca infc ;
LIST AdvclAble = ("כי" conj @mark) ("אם" conj @mark) ;
LIST ActuallyAcl = (Genesis ClauseRoot ph47742) ;
LIST OrphanInfc = (Genesis w18716) ;
LIST NonFCROverride = (Genesis w5072) ;
LIST FCRSkip = @csubj @acl @advcl rela:Attr ;
LIST SmallQstQ = inrg prin ;
LIST SmallQstPrn = prde prn ;
LIST AdjNonAcl = (Genesis w23609) ;
LIST SubjAble = subs prps nmpr prde prn prin ;
LIST NonCsubjOverride = (Genesis w1956) ;
LIST CsubjOverride = (Genesis w1006) (Genesis w5072) ;
LIST ObjAble = subs prn nmpr prin prde ;
LIST ObjIsh = @obj ProbablyObj ;
LIST XcompOverride = (Genesis w17124) (Genesis w26289) ;
LIST AclChain = (Genesis w603) ;
LIST RelSkip = (Ruth w550) ;
LIST RelToPrn = (Ruth w1714) ;
LIST ConjTypes = CPen NmCl MSyn ;
LIST AclAble = subs adjv ptcp ptca nmpr ;
LIST AclCompOk = (Exodus w3801) (Exodus w5417) ;
LIST AclCompNotOk = (Genesis w1179) (Genesis w12528) (Genesis w12613) (Ruth w712) (Genesis w26221) (Genesis w26340) (Genesis w26404) (Genesis w24882) ;
LIST AclMultiTarget = (Genesis w391) (Genesis w9660) (Genesis w9740) ;
LIST XorO = (@xcomp ProbablyObj) @obj ;
LIST PrepVerbChain = (Genesis w13720) (Genesis w16269) ;
LIST CRconj = @ccomp @root @parataxis ;
LIST CcompAble = "חלל" "נתן" "מהר" "צוה" "שׁמע" ;
LIST AttrSkipAcl = (Genesis w22880) ;
LIST ClauseCon = @conj @parataxis @xcomp ;
LIST ConjToAdvcl = (Genesis w772) ;
LIST ConjToAcl = (Genesis w845) (Genesis w5094) ;
LIST DontConj = @conj @acl @nmod @xcomp @appos @advcl @nmod:poss (@ccomp N) @obl @mark HasConj @csubj skipconj (@ccomp rela:Objc) ;
SET DetAble = Noun OR ADJ OR PRON ;
SET AdjNonBar = NonJoiner - (nega) ;
SET ProbablyNumber = Number + NumberLabel ;
SET CaseAble = Noun - ProbablyNumber OR PRON OR (verb infc) - QMark OR (verb infa) OR CaseAbleAdv + ADV OR (prin) OR (inrg);
SET AfterPrep = Det OR @case OR @nummod OR @cc OR ProbablyNumber ;
SET NonAppos = NPHead - @appos ;
SET SpecialMark = MarkToAcl OR NestMark OR PreMark OR PostMark ;
SET NonNmCl = (*) - (NmCl) - (prn) ;
SET CorR = (conj CP) OR RelMark ;
SET CorM = CR OR (nmcp) - @cop ;
SET MSynIsh = CorR + @cc OR @advmod ;
LIST ActuallyParataxis = (Genesis w888) (Genesis w921) (Genesis w935) (Genesis w2979) (Genesis w4072) (Genesis w4208) (Genesis w12675) (Genesis w12530) (Genesis w7997) (Genesis w23609) ;
LIST ActuallyNsubj = (Genesis w886) (Genesis w919) (Genesis w933) ;
LIST ActuallyCsubj = (Genesis w5072) ;
LIST ActuallyObl = (Genesis ph57618) ;
LIST QuoteSkipAcl = (Genesis w7270) ;
LIST ParenSent = (Genesis s82236) ;

########################################
# INDIVIDUAL WORDS
########################################

BEFORE-SECTIONS

####################
# Corrections
####################

LIST MislabeledAsNarrative = w1404 w1405 w1423 w1424 w14251 w14252 w14253 (Genesis s80885) (Ruth s5672) (Ruth s5673) (Genesis s83562) (Ruth s5647) (Ruth s5650) (Ruth s5651) (Genesis s85072) (Genesis s83308) (Genesis s83309) (Genesis s84608) (Genesis s83116) (Genesis s83082) (Genesis s81615) (Genesis s81616) (Genesis s81881) ;
SUBSTITUTE (N) (Q) MislabeledAsNarrative ;

LIST UnknownShouldBeNarrative = (Genesis w2137) ;
SUBSTITUTE (?) (N) UnknownShouldBeNarrative ;

SUBSTITUTE (infc) (infa) (Ruth w797) ;

ADD (m) Noun + Masculine - AGen ;

####################
# Nested Quotations
####################

LIST DoubleQuoteGen = s80831 s80834 s80836 s80837 s80886 s81424 s81443 s81543 s81737 s81766 s81767 s81785 s81829 s81933 s81999 s82001 s82028 s82037 s82159 s82295 s82315 s82367 s82380 s82382 s82410 s82412 s82413 s82446 s82450 s82599 s82626 s82629 s82776 s82946 s83252 s83255 s83285 s83303 s83318 s83319 s83327 s83431 s83432 s83449 s83459 s83470 s83474 s83479 s83480 s83482 s83510 s83626 s83628 s83906 s83919 s84071 s84283 s84313 s84382 s84435 s84464 s84492 s84537 s84545 s84551 s84552 s84555 s84638 s84673 s84681 s84708 s84709 s84719 s84722 s84765 s84804 s84805 s84828 s84934 s84941 s84943 s85134 s85229 s85230 s85261 s85262
c29820 ; # TODO: handle rela:Objc properly
LIST DoubleQuoteRuth = s5648 s5649 s5720 s5825 ;
SET DoubleQuote = (Genesis) + DoubleQuoteGen OR (Ruth) + DoubleQuoteRuth ;
SUBSTITUTE (Q) (QQ) DoubleQuote ;

ADD NQ (*) - QuoteLevel ;

####################
# MWE names
####################

SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בית" wp1) ;
SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בן" wp1) ;
SUBSTITUTE (nmpr) (subs retag:nmpr m) ("אל" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("לחם" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("צדק" wp2) ;
SUBSTITUTE ("מלכי" nmpr) ("מלך" subs c retag:nmpr) (wp1 Genesis w6557) ;
SUBSTITUTE ("עמי" nmpr) ("עם" subs retag:nmpr has_prn) ("עמי" wp2) ;
SUBSTITUTE ("אוני" nmpr) ("און" subs retag:nmpr has_prn) ("אוני" wp2) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("עם" subs retag:nmpr) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("און" subs retag:nmpr) ;

MAP @flat:name (nmpr wp2) IF (-1* (nmpr wp1) BARRIER NonJoiner) ;
SETPARENT @flat:name TO (-1* (nmpr wp1)) ;

####################
# Retagging
####################

# quotation
MERGECOHORTS ("<le'emor>" "$2$1"v SCONJ *) ("(אמר)"r verb infc) WITH (-1 ("(ל)"r prep)) ;

# Substantivized adjectives
SUBSTITUTE (adjv) (subs retag:adjv) (c) ;
SUBSTITUTE (adjv) (subs retag:adjv) (a) (1 BD) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv a) (1 (prn)) ;
# TODO: does this really apply to all gentillics?
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl pl) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (NEGATE 0* (subs) - (retag:adjv gntl) OR (nmpr) BARRIER PB) ;

# Participles in smixut
SUBSTITUTE (verb) (subs retag:verb) Participle + NPish ;

# Adverbs tagged subs
SUBSTITUTE (subs) (advb retag:subs) (padv) - (NP) (-1 BD) (1* BD BARRIER (*) - (punct) - (prn ModS)) ;

# Determiner on clause participles
SUBSTITUTE (art) (conj retag:art) (CP Rela) ;

# Prepositions tagged as nouns
SUBSTITUTE (subs) (advb retag:subs) ("אחר" subs ppre AdvP) (1 BD) ;
SUBSTITUTE (subs) (prep retag:subs) ("אחר" subs ppre) ;
SUBSTITUTE (subs) (prep retag:subs) ("בין" subs ppre) ;
SUBSTITUTE (subs) (prep retag:subs) (ppre CP Conj) IF (NOT 0 SubsOverride) ;

SUBSTITUTE (prep) (conj retag:prep) ConjAblePrep + (CP) ;

# yesh and ein
SUBSTITUTE (subs) (verb retag:subs ClauseRoot) (nmcp) ;

# interrogative adverbs
SUBSTITUTE (inrg) (advb retag:inrg) ItgAdv ;

####################
# MWE conjunctions
####################

SETPARENT ("אם" conj) OR ("כי" conj) TO (-1* ("עד" prep) BARRIER NonJoiner) ;
MAP @fixed ("אם" conj) OR ("כי" conj) IF (-1* ("עד" prep) BARRIER NonJoiner) ;
SUBSTITUTE (prep) (conj retag:prep) ("עד") IF (c @fixed) ;

####################
# Helper labels
####################

ADD (NonAcc) ("את" prep Cmpl) + $$ClauseType - (NonAcc)
    IF (0* ("את" prep Objc) + $$ClauseType BARRIER SB) ;
ADD PPHead PPHeadOverride - PPHead ;

SUBSTITUTE (ClausePhraseRoot) (WhyAreVocativesTheirOwnClause) VoctNonCROverride ;
SUBSTITUTE (ClausePhraseRoot) (WhyAreVocativesTheirOwnClause) (Voct) IF (0* (ClausePhraseRoot) - (Voct) BARRIER SB) ;

ADD (ClausePhraseRoot) ("חלילה" intj) - (ClausePhraseRoot) ;
SUBSTITUTE (ClausePhraseRoot) (InterjectionOverride) (*) - (intj)
    IF (0* ("חלילה" intj) BARRIER CB) ;

ADD (skipconj) DontConjTo - (skipconj) ;
ADD HasConj HasConjOverride - HasConj ;

####################
# Consistent labels
####################

MAP @punct (punct) ;
MAP @det Det ;
MAP @mark SCONJ + (conj CP) ;
MAP @mark ("ה" inrg) ;
MAP @obj ("את") + Pr IF (1 RelMark) ;
MAP @obl Pr IF (1* RelMark BARRIER NonJoiner) ;
MAP @case Pr ;
MAP @cc (conj) - (Rela) ;
MAP @advmod ADV - (ClausePhraseRoot) - PPHead ;
MAP @advmod ADV + (MSyn) ;
MAP @advmod ADV + (ClausePhraseRoot) IF (0* PRON BARRIER BD) ;
MAP @advmod ("למה" inrg) ;
MAP @discourse (intj) - (ClausePhraseRoot) ; # TODO: is there a better way to handle הנה?

####################
# Pronoun suffixes
####################

SUBSTITUTE ("prn") ("אני") ("prn" prn p1 sg) ;
SUBSTITUTE ("prn") ("אנחנו") ("prn" prn p1 pl) ;
SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("את") ("prn" prn p2 f sg) ;
SUBSTITUTE ("prn") ("אתם") ("prn" prn p2 m pl) ;
SUBSTITUTE ("prn") ("אתן") ("prn" prn p2 f pl) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("היא") ("prn" prn p3 f sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;
SUBSTITUTE ("prn") ("הן") ("prn" prn p3 f pl) ;

########################################
# PHRASES
########################################

SECTION

####################
# Pronoun suffixes
####################

MAP @nsubj (prn) + NsubjPrn ;
MAP @obj (prn) + ObjPrn ;
MAP (NPHead @obj) (prn Objc) IF (-1 Pr + ("את") - etNotAcc) ;
SETPARENT (prn @obj) OR (prn @nsubj) (NOT p (*)) TO (-1 (verb) OR (intj ClausePhraseRoot)) ;
MAP @nmod:poss (prn) IF (-1 Noun - (verb) - Number) ;
SETPARENT @nmod:poss (NOT p (*)) TO (-1 Noun) ;
MAP @nmod (prn) IF (-1 Number) ;
SETPARENT (prn @nmod) (NOT p (*)) TO (-1 Number) ;

####################
# Numbers
####################

MAP @flat BigNumber + Number IF (-1* Number BARRIER NonJoiner) ;
SETPARENT @flat + Number (NOT p (*)) TO (-1* Number BARRIER NonJoiner) ;
MAP @conj Number IF (-1* @cc BARRIER NonJoiner LINK -1* Number BARRIER NonJoiner - @flat) ;
SETPARENT @cc (NOT p (*)) TO (1 Number + @conj) ;
SETPARENT Number + @conj (NOT p (*))
    TO (-1* Number - @flat BARRIER NonJoiner - @cc - @flat) ;
SETPARENT Number + (c) (NOT p (*)) TO (1* Noun - Number BARRIER NonJoiner - Det) ;
SETPARENT Number (NOT p (*)) TO (c Number + (c @conj) LINK 1* Noun) ;
SETPARENT Number (NOT p (*)) TO (-1 Noun - Number) ;
SETPARENT Number (NOT p (*))
    TO (1* Noun - Number OR NumberedOverride BARRIER NonJoiner - Det - Number - @cc) ;
SETPARENT Number (NOT p (*))
    TO (0* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
MAP @nummod Number IF (p Noun OR (prn) OR NumberedOverride) (NEGATE c @nmod) ;

####################
# Smixut
####################

# conjunction within smixut
# (kinda weird, but arg structure doesn't make sense otherwise)
MAP @conj $$Lemma + (subs) IF (-1* NonJoiner LINK 0 @cc LINK -1* NonJoiner - (prn) LINK 0 $$Lemma + (subs)) (NEGATE 1* PrnNmodToSublist BARRIER BD) ;
SETPARENT @conj + $$Lemma + (subs) (NOT p (*))
    TO (-1* NonJoiner LINK 0 @cc LINK -1* NonJoiner - (prn) LINK 0 $$Lemma + (subs)) ;
SETPARENT @cc (NOT p (*)) TO (1 (subs @conj)) ;

MAP @compound:smixut Noun OR ADJ OR (prin) IF (-1* Noun + (c) - Number BARRIER NonJoiner - Det - @nummod - @flat - @cc - (card @conj)) ;
SETPARENT @compound:smixut (NOT p (*)) TO (-1* Noun - @nummod - @flat) ;

####################
# Determiners
####################

SETPARENT Det (NOT p (*)) TO (1 DetAble) ;
MAP @det PrnMaybeDet IF (-1 Det LINK -1* Noun BARRIER NonJoiner) ;
SETPARENT @det (NOT p (*)) TO (-1* Noun BARRIER NonJoiner - Det) ;
MAP @det PrnMaybeDet IF (-1* Number BARRIER NonJoiner) ;
SETPARENT @det + PrnMaybeDet (NOT p (*)) TO (-1* Number BARRIER NonJoiner) ;

####################
# Adjectives
####################

MAP @conj ADJ IF (-1* @cc BARRIER AdjNonBar LINK -1* ADJ BARRIER AdjNonBar) ;
MAP @conj ADJ IF (-1* ADJ BARRIER AdjNonBar)
                 (1* @cc BARRIER AdjNonBar LINK 1* ADJ BARRIER AdjNonBar) ;
SETPARENT ADJ + @conj (NOT p (*))
    TO (-1* ADJ - @conj BARRIER AdjNonBar - @cc) ;
SETPARENT @cc (NOT p (*)) (-1* ADJ BARRIER NonJoiner) TO (1* ADJ BARRIER AdjNonBar) ;

SETPARENT ADJ + $$AGen + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$AGen + $$ANum + $$ADet BARRIER PB OR Pr) ;
SETPARENT ADJ + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$ANum + $$ADet - AGen BARRIER PB OR Pr) ;
MAP @amod ADJ IF (p Noun) ;

UNMAP @advmod IF (NOT 0 (MSyn)) (NEGATE 0* BetterHeads BARRIER SB) ;
ADD CR AdvIsh - CR ;

####################
# Prepositions
####################

SETPARENT @case (NOT p (*)) TO (1* CaseAble BARRIER NonJoiner - AfterPrep) ;
SETPARENT @case (NOT p (*)) TO (1*A ADJ BARRIER NonJoiner - AfterPrep LINK NOT p (*)) ;

####################
# Weird List Behavior
####################

MAP (@nmod prn_sub) (prn) IF (c PrnNmodToSublist) ;
SETPARENT (@nmod prn_sub) (NOT p (*)) TO (-1* ConjHeadOverride BARRIER PB) ;
SETPARENT (@nmod prn_sub) (NOT p (*))
    TO (-1* BD LINK 1* @cc LINK 1* Noun BARRIER NonJoiner - Det - Pr) ;
ADD (conjhead) ConjHeadOverride - (conjhead) ;
ADD (conjhead) (*) - (conjhead) IF (c (@nmod prn_sub)) ;

####################
# Label NP heads
####################

ADD PPHead Noun OR PRON OR ADJ OR ADV IF (NOT p (*)) (NOT 0 PPHead) (c @case - ("את") OR etNotAcc) ;
ADD NPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead OR NPHead) ;

####################
# NP/PP conjunctions
####################

SETPARENT REPEAT @cc (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;
ADD REPEAT HasConj NPHead OR PPHead IF (NOT 0 HasConj) (c @cc) ;

####################
# NP/PP adverbs
####################

SETPARENT @advmod + NPIsh (NOT p (*)) TO (1* NPHead OR PPHead OR ADJ BARRIER PB) ;

####################
# Apposition
####################

MAP @nmod (*) IF (c NmodOverridePrep) ;

MAP REPEAT @appos NPHead - HasConj - (nmpr) IF (-1* NPHead OR PPHead BARRIER BD) ;
MAP REPEAT @appos NPHead - HasConj + (nmpr) IF (-1* NPHead + Titles BARRIER BD OR NPHead OR PPHead) ;

####################
# VP
####################

MAP @obl NegObl IF (1* (infc) BARRIER NonJoiner) ;
SETPARENT NegObl (NOT p (*)) TO (1* (infc) BARRIER NonJoiner) ;

MAP @acl (verb infc VP) IF (-1 (subs c) - NegObl) ;
SETPARENT (verb infc VP @acl) (NOT p (*)) TO (-1 (subs c)) ;

SETPARENT @cc (NOT p (*)) (-1 (infa)) TO (1 (infa)) ;
MAP @conj (infa) - CR IF (c @cc) ;
SETPARENT (infa) (NOT p (*)) (c @cc) TO (-2 (infa)) ;

####################
# Connect NPs
####################

MAP REPEAT @conj PPHead + HasConj + (/^\(ph\\d+\)$/r)
    IF (-1* PPHead + (VSTR:$1)) ;
MAP REPEAT @conj PPHead IF (-1* PPHead BARRIER BD OR NonAppos)
                           (1* PPHead + HasConj BARRIER BD OR NonAppos) ;

SECTION
SETPARENT PPHead + @conj (NOT p (*))
    TO (-1* PPHead - @conj BARRIER BD OR NonAppos) ;

SECTION
# TODO: any better way to do this?
SETPARENT (w189 Genesis) (NOT p (*)) TO (-1* (w185)) ;
SETPARENT (Genesis w3459) (NOT p (*)) TO (-1* NPHead - (verb)) ;
SETPARENT (Genesis w14323) (NOT p (*)) TO (-1* (prn)) ;
SETPARENT (Genesis w4544) OR (Genesis w2674) OR (Genesis w7425) (NOT p (*))
    TO (-1* (subs)) ;
MAP @conj (Genesis w2674) OR (Genesis w6219) ;
SETPARENT (Genesis w2671) OR (Genesis w2672) (NOT p (*))
    TO (1* (Genesis w2674)) ;
SETPARENT (Genesis w6219) OR (Genesis w6222) OR (Genesis w6226) (NOT p (*))
    TO (-1* (Genesis w6216)) ;

MAP @appos ApposOverride;
SETPARENT CaseAble + ConjToAppos (NOT p (*)) TO (-1* @appos) ;
SETPARENT CaseAble + ConjToSmixut (NOT p (*)) TO (-1* @compound:smixut) ;
MAP REPEAT @conj NPHead + HasConj + (/^\(ph\\d+\)$/r)
    IF (-1* NPHead + (VSTR:$1)) ;
MAP @conj NPHead IF (-1* NonAppos BARRIER BD) (1* NPHead + HasConj BARRIER BD) ;
SETPARENT NPHead + @conj + (/^\(ph\\d+\)$/r) (NOT p (*))
    TO (-1* (conjhead VSTR:$1) OR NonAppos - @conj + (VSTR:$1)) ;

SETPARENT ApposToConjHead (NOT p (*)) TO (-1* (conjhead)) ;

SETPARENT FamilyOrTitle + (subs) - FamilyOrTitleSkip + $$AGen (NOT p (*))
    TO (-1* (nmpr a) - (topo) - @flat:name + $$AGen BARRIER NonJoiner - @flat:name) ;

SETPARENT ApposOverAcl + (/^\(ph\\d+\)$/r) (NOT p (*))
    TO (-1* ApposAble + (VSTR:$1)) ;
SETPARENT ApposOverAcl (NOT p (*))
    TO (-1* (rela:Attr) LINK -1* CB LINK -1* ApposAble) ;

SETPARENT CaseAble + ApposToLast (NOT p (*)) TO (-1* ApposAble) ;
SETPARENT (prn) (c Pr + ApposToLast) (NOT p (*)) TO (-1* ApposAble) ;
SETPARENT CaseAble - ApposToLast - ConjToAppos - (prn ModS) (NOT p (*))
     TO (-1* BD LINK 1*A CaseAble - @compound:smixut BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP KEEPORDER @appos CaseAble IF (c @case + $$Lemma) (p CaseAble LINK c @case + $$Lemma) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @appos CaseAble - (verb infc) IF (p CaseAble - CR) ;

SETPARENT PPHead (NOT p (*)) TO (-1* NPHead BARRIER PB) ;
MAP @nmod PPHead IF (p NPHead OR PPHead) ;

SETPARENT NPHead + @appos (NOT p (*)) TO (-1* NorP - @appos BARRIER BD) ;

SETPARENT (nmpr @appos) TO (p ("אלהים") LINK c (@compound:smixut)) ;

####################
# Other labels
####################

MAP @cop (vbcp) + $$ClauseType OR (aux nmcp) IF (0* (PreC) + $$ClauseType BARRIER SB) ;
SETPARENT @cop + $$ClauseType (NOT p (*)) TO (0* (PreC) + $$ClauseType + NorP - @conj BARRIER SB) ;

SECTION # conjunction

SETPARENT (conj PP) (NOT p (*)) TO (1* (subs PP)) ;
MAP @conj (subs PP) - (PreC) - CR IF (0 (subs) LINK c @cc) (NOT c @cop) ;
SETPARENT (subs PPHead @conj /^\(ph\\d+\)$/r) - CR (NOT p (*))
    TO (-1* CaseAble + (VSTR:$1) - @conj - @compound:smixut) ;
SETPARENT (subs PPHead @conj) - CR (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;

SECTION # helper labels

TEMPLATE CRp = (NOT 0 CR LINK NEGATE 0* CR BARRIER CB) ;

ADD CR (ClausePhraseRoot) - CR + (/^(c\\d+\)$/r) - QMark IF (NEGATE -1* (VSTR:$1) + CR) ;

# irregular conjunction attachment
SETPARENT ConjSkipClause (NOT p (*)) TO (1* CR LINK 1* CR) ;

####################
# Blah
####################

SETPARENT (Genesis w1251) (NOT p (*)) TO (-1* CR LINK -1* CR) ;
SETPARENT (Genesis w1256) (NOT p (*)) TO (-1* CR) ;
SETPARENT (Genesis w21545) (NOT p (*)) TO (-1* NPHead) ;
MAP @nmod (Genesis w21545) ;

####################
# Attach by clause label
####################

SETPARENT (/^\(c\\d+\)$/r) - CR - NoGlom (NOT p (*)) TO (0* (VSTR:$1) + CR) ;

MAP @obl ActuallyObl ;

MAP @nsubj SubjIsh - CR IF (p CR LINK NEGATE c @nsubj) ;
MAP @dislocated (Subj) - CR IF (p CR) ;
MAP @obj (Objc) - CR - (Ellp) IF (p CR LINK NEGATE c @obj) ;
MAP @xcomp (Objc) - CR - (Ellp) OR (PrAd) - CR IF (p CR) ;
MAP @obj (ProbablyObj InrP) - CR - (Ellp) IF (p CR LINK NEGATE c @obj) ;

MAP @advcl (infa AdvP) IF (NEGATE 1* NonJoiner LINK 0 BD) (NEGATE c @cop) ;
MAP @advmod (verb infa) + $$Lemma - CR IF (p CR + $$Lemma) ;
MAP @advmod (verb infa AdvP) - CR IF (p NPHead) ;

MAP @orphan OblIsh + (Ellp) - CR OR (Objc Ellp) - CR IF (p CR + (Ellp)) ;
MAP @obl OblIsh - CR IF (p CR) ;

ADD CR (Pred) - (vbcp) - CR - QMark ;
ADD CR PredIsh IF (T:CRp) ;
ADD CR CopIsh - NonCopIsh IF (T:CRp) ;

ADD (PrepVerb) (verb) - (PrepVerb) - OrphanPrepVerb IF (c @case OR ("בלת" @obl)) ;
ADD (PrepVerb) (*) - (PrepVerb) IF (c @cop LINK c @case) ;

SECTION # clause con

ADD HasRel CR - HasRel - NonRelOverride IF (c @mark + (Rela) OR RelMark) ;
ADD HasConj CR - HasConj IF (c @cc) ;
ADD HasMark CR - HasMark + (infc) IF (c @case) ;
ADD HasMark CR + (PrepVerb) - HasMark ;
ADD HasMark CR - HasMark - HasRel - NonMarkOverride IF (c @mark - (inrg ques) - QMark - (Rela) - RelMark - NonMarkingSCONJ) ;
ADD HasMark CR + MarkOverride - HasMark ;

SECTION

SETCHILD REPEAT CR + (/^par:\(c\\d+\)$/r rela:PreC) - ActuallyCsubj
    TO (-1*A CR + (VSTR:$1 Subj) LINK NOT p (*)) ;
MAP REPEAT @nsubj CR + (subs Subj) IF (p CR + (rela:PreC)) ;

MAP @ccomp ActuallyCcomp ;
MAP @advcl ActuallyAdvcl ;
MAP @nsubj ActuallyNsubj ;
MAP @parataxis ActuallyParataxis ;

SETPARENT CR (NOT p (*)) TO (c RelMark LINK -1* Pr BARRIER NonJoiner) ;
MAP @acl CR IF (p Pr) ;
SETPARENT Pr + (/^par:\(c\\d+\)$/r) (NOT p (*)) (c CR) TO (0* CR + (VSTR:$1)) ;
SETPARENT CR + (/^par:\(c\\d+\)$/r) (NOT p (*)) TO (0* CR + (VSTR:$1)) ;
SETPARENT CR + (rela:Coor) TO (p (rela:Coor) LINK p (*)) ;

SETPARENT CR + RelaCRToPrev (NOT p (*)) TO (-1* CR) ;
SETPARENT CR + RelaNonAcl - HasRel (NOT p (*)) TO (0* CR - Rela BARRIER SB) ;

MAP @xcomp CR + (rela:Objc) IF (p CR + ObjcXcomp) ;
MAP @xcomp CR + (rela:Adju) IF (p CR + AdjuXcomp) ;

MAP @parataxis CR + (rela:Adju Ellp Subj) IF (p CR) ;
MAP @acl CR + (rela:Adju) - (PrepVerb) IF (p CR + (subs)) ;
MAP @appos CR + (rela:Coor) - HasConj IF (p CR) (NEGATE 0* (ClauseRoot rela:Coor HasConj) BARRIER SB) ;

MAP @ccomp CR + (rela:Objc) IF (p CR) ;
MAP @advcl CR + (rela:Adju) IF (p CR) ;
MAP @conj CR + (rela:Coor) IF (p CR) ;
MAP @csubj CR + (rela:Subj) IF (p CR) ;

SECTION

SETPARENT (HasMark HasConj) (NOT p (*))
    TO (-1* HasMark - HasConj BARRIER PlainC) ;
MAP @conj (HasMark HasConj) - NestMark IF (p HasMark) ;

SETPARENT (verb) + Ptc - QMark - NonAclOverride (NOT p (*)) TO (-1* Noun - @compound:smixut BARRIER NonJoiner - BD - @det - @compound:smixut) ;
MAP @acl (verb) + Ptc - QMark IF (p Noun) ;

MAP @xcomp (verb infc InfC) - QMark IF (-1* XcompInf + (verb) BARRIER SB OR @mark) ;

MAP @xcomp (NPHead PreC) IF (0* (vbcp infc InfC) BARRIER CB LINK -1* XcompInf + (verb) BARRIER SB OR @mark) ;

SETPARENT (@xcomp InfC) (NOT p (*)) TO (-1* XcompInf + (verb) BARRIER SB) ;

MAP @cop (vbcp) IF (1* Participle OR (infc) BARRIER (*) - BD - ("ל" prep)) ;
SETPARENT @cop (NOT p (*)) TO (1* Participle OR (infc) BARRIER (*) - BD - ("ל" prep)) ;

MAP @advcl (infc) IF (-1 ("ל" prep) LINK -1* (verb nmcp) BARRIER SB) ;
MAP @xcomp Participle - (Subj) - HasRel IF (-1* (verb nmcp) BARRIER SB) ;
SETPARENT @advcl OR @xcomp (NOT p (*)) TO (-1* (verb nmcp) BARRIER SB) ;

SECTION

SETPARENT MarkToAcl (NOT p (*)) TO (0* CR + HasRel) ;
SETPARENT NestMark (NOT p (*)) TO (0* CR + HasMark) ;
SETPARENT PreMark (NOT p (*)) TO (1* CR - HasMark) ;
SETPARENT PostMark + $$QuoteLevel (NOT p (*)) TO (-1* CR + $$QuoteLevel - HasMark - HasRel) ;
SETPARENT HasMark (NOT p (*))
    TO (0* PlainC - @csubj - (rela:Subj) BARRIER CR - HasMark - HasRel OR SB OR ("ה" inrg)) ;

MAP @csubj CR + (rela:Cmpl) IF (p ("חלילה" intj)) ;

SETPARENT QMark (NOT p (*))
    TO (1* (FullClauseRoot Q) OR (FullClauseRoot QQ)) ;

SETPARENT CR + $$Domain - SpecialMark - HasRel (c AdvclAble) (NOT p (*))
    TO (-1* PlainC + $$Domain BARRIER Domain - $$Domain) ;
SETPARENT (verb infc) + $$Domain - QMark (NEGATE c @cc) (NOT p (*))
    TO (-1* CR + $$Domain - @csubj - (rela:Subj) BARRIER Domain - $$Domain) ;

MAP @acl ActuallyAcl ;

MAP @advcl CR IF (c PrAdvcl + @case) ;
MAP @advcl CR IF (c AdvclAble) (p AdvclMarkVerb) ;
MAP @xcomp CR IF (c AdvclAble) (p XcompVerb) ;
MAP @xcomp CR IF (c AdvclAble) (p CcompVerb LINK c @obj) ;
MAP @ccomp CR IF (c AdvclAble) (p CcompVerb) ;
MAP @advcl CR IF (c AdvclAble) (p (*)) ;
MAP @advcl (PrepVerb) IF (p (*)) ;

MAP @advcl CR + HasMark - OrphanInfc IF (p CR) ;

SETPARENT @ccomp (NOT p (*)) TO (0* CcompVerb BARRIER SB) ;

MAP (@parataxis ish_recip) ("אישׁ" ClauseRoot Ellp rela:Adju)
    IF (-1* (verb) BARRIER NonJoiner - BD) ;
SETPARENT (ish_recip) (NOT p (*)) TO (-1* (verb)) ;

ADD FullClauseRoot PlainC - @acl - FullClauseRoot - NonFCROverride ;

SECTION

SETPARENT FullClauseRoot + HasConj + $$Domain (NOT p (*))
    TO (-1* FullClauseRoot - HasConj + $$Domain - FCRSkip - ParenSent BARRIER FullClauseRoot - $$Domain - ParenSent) ;

MAP @conj FullClauseRoot + HasConj IF (p FullClauseRoot) ;

MAP @conj Inf IF (c @cc LINK -1* Inf BARRIER SB OR CR - Inf) ;
SETPARENT Inf + @conj (NOT p (*))
    TO (c @cc LINK -1* Inf - @conj BARRIER SB OR CR - Inf) ;

SECTION # adjacent words

MAP @nsubj SmallQstQ - CR IF (-1 BD) (1* SmallQstPrn BARRIER NonJoiner LINK 1 BDsent) ;

SECTION # phrase-internal structure

ADD (ClauseRoot) (adjv AjCl) - (ClauseRoot) IF (NOT p (*)) ;
MAP @acl (ClauseRoot AjCl) - AdjNonAcl
    IF (-1* CB BARRIER SB OR @mark LINK -1* NPHead BARRIER BD) ;

####################
# Label verb arguments
####################

SECTION

### SUBJECTS

MAP @nsubj SubjAble + (Subj) - CR ;

MAP @nsubj SubjAble + (Subj NmCl ClausePhraseRoot)
    IF (1* CR + HasRel BARRIER CR) ;
SETPARENT @nsubj + (NmCl ClausePhraseRoot) (NOT p (*))
    TO (1* CR + HasRel BARRIER CR) ;

MAP @csubj CR + (rela:Subj) - NonCsubjOverride ;

MAP @csubj CsubjOverride ;
SETPARENT @csubj (NOT p (*)) TO (0* CR BARRIER SB) ;

### OBJECTS

ADD REPEAT (ProbablyObj) ObjAble + (Objc) - (ProbablyObj) ;
ADD REPEAT (ProbablyObj) ObjAble + (InrP) - (ProbablyObj) ;
ADD REPEAT CR (ProbablyObj Ellp) - CR ;

MAP @xcomp XcompOverride ;

### OBLIQUES

MAP @obl PPHead + (PreC) IF (-1* (nmcp) BARRIER SB) ;
MAP @obl Noun + OblIsh - CR ;

MAP @obl (PreC) - CR ;

MAP @vocative Noun + (Voct) - CR ;

####################
# Attach verb arguments
####################

SECTION

SETPARENT CR + (rela:Attr /^par:\(w\\d+\)$/r) (NOT p (*)) TO (-1* (VSTR:$1)) ;

MAP (@conj rel_conj) (ClauseRoot NmCl rela:Coor) IF (-1* RelMark BARRIER CB) ;
MAP @acl (ClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
MAP @acl CR + (rela:Attr) IF (c RelMark) (p (*)) ;
SETPARENT @acl + AclChain (NOT p (*)) TO (-1* @acl LINK p (*)) ;
SETPARENT (subs @acl) - AclChain (NOT p (*)) TO (-1* Noun - (verb) - @flat:name OR Pr + @obj OR Pr + @obl) ;

SETPARENT @acl + RelToPrn (NOT p (*)) TO (c RelMark LINK -1* (prn)) ;
SETPARENT @acl OR CR + @conj + (rela:Coor rel_conj) (NOT p (*))
    TO (-1* NorP - RelSkip BARRIER SB) ;

SECTION

SETPARENT VerbArgs + $$ClauseType - Pr (NOT p (*))
    TO (0* CR + $$ClauseType BARRIER SB) ;

SECTION

SETPARENT (conj CP) (NOT p (*)) TO (1 PB LINK 1 @cop LINK p (*)) ;
MAP @acl CR - NonAclOverride IF (c RelMark) (NEGATE c (@nsubj NmCl)) ;
SETPARENT @acl (NOT p (*)) TO (-1* AclMultiTarget BARRIER SB) ;
SETPARENT @acl (NOT p (*)) TO (c @mark LINK -1* Pr BARRIER NonJoiner) ;
SETPARENT @acl + AclCompNotOk (NOT p (*))
    TO (-1* CB LINK -1* AclAble - @compound:smixut BARRIER BD) ;
SETPARENT @acl - AclCompNotOk - AclChain (NOT p (*))
    TO (-1* CB LINK -1* AclAble - @nummod - @amod BARRIER BD) ;

SETPARENT (verb /^par:\(ph\\d+\)$/r) + Ptc (p (*) - (VSTR:$1)) TO (-1* NPHead + (VSTR:$1)) ;

MAP @ccomp QMark IF (NEGATE 1* CR) ;
MAP @mark QMark ;

SECTION

SETPARENT CR (NOT p (*)) TO (c RelMark LINK -1* CB BARRIER Pr LINK -1* NorP BARRIER PB) ;
MAP @acl CR IF (p NorP) (c RelMark) ;

SETPARENT XorO + $$ClauseType (NOT p (*))
    TO (0* CR + $$ClauseType BARRIER SB) ;

ADD CR (*) - CR IF (c @nsubj) ;

SECTION

ADD CR NPHead OR PPHead IF (c @mark) (NOT 0 CR) ;
SETPARENT CorR + ConjTypes + @mark (NOT p (*)) TO (1* CorM - @acl) ;

MAP @advcl (ClauseRoot Q HasMark)
    IF (c @mark - (inrg ques) - QMark) (1* (ClauseRoot Q) BARRIER NonQuote LINK NEGATE c @mark) ;
SETPARENT MSynIsh + ConjTypes (NOT p (*)) TO (1* CorM - @advcl - @acl) ;
MAP @conj (ClauseRoot Q)
    IF (c @cc) (-1* (ClauseRoot Q) - @acl - @advcl - @xcomp - HasMark BARRIER (N)) ;
MAP @parataxis (ClauseRoot Q) - (infc) - HasMark - HasConj
    IF (NEGATE c @cc) (NEGATE c @mark)
       (-1* (ClauseRoot Q) - @acl - @advcl - @csubj - (HasMark @conj) BARRIER (N)) ;
MAP @ccomp (ClauseRoot Q)
    IF (NEGATE c @mark) (-1* CR + NonQuote)
       (NOT -1* (ClauseRoot Q) - @acl BARRIER (N)) ;
SETPARENT (ClauseRoot Q HasConj) - HasMark (NOT p (*))
    TO (-1* PlainNC + (Q) BARRIER CR + NonQuote) ;
SETPARENT (ClauseRoot Q @conj) (NOT p (*))
    TO (-1* (ClauseRoot Q) + CRconj) ;

MAP @root CR IF (NOT -1* CR - @advcl - @acl - @csubj) ;

SETPARENT @advcl + $$Domain (NOT p (*)) (NEGATE 0* CR BARRIER SB) TO (1* CR + $$Domain - @advcl) ;

SETPARENT (@ccomp Q) + QuoteSkipAcl (NOT p (*)) TO (-1* CR - @mark - @acl) ;
SETPARENT (@ccomp Q) (NOT p (*)) TO (-1* (quot ClauseRoot) - @mark) ;
SETPARENT @ccomp (NOT p (*)) TO (-1* CcompAble + CR) ;

SETPARENT CR + (rela:Attr) - AttrSkipAcl (NOT p (*)) TO (-1* CB LINK -1* ApposAble) ;
MAP @acl CR + (rela:Attr) IF (p ApposAble) ;

MAP (@conj ClauseRoot) CR + $$NonQuote IF (-1* CR + $$NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) CR + $$NonQuote - (PrepVerb) IF (-1* CR + $$NonQuote) ;

SETPARENT ConjToAdvcl (NOT p (*)) TO (-1* CR + @advcl) ;
SETPARENT ConjToAcl (NOT p (*)) TO (-1* @acl) ;

SETPARENT CR + ClauseCon + $$Domain (NOT p (*)) TO (-1* CR + $$Domain - DontConj - ParenSent) ;

SECTION

MAP @dislocated SubjAble + (CPen) ;
SETPARENT (@dislocated Frnt) (NOT p (*)) TO (-1* @mark BARRIER (*) - BD LINK p (*)) ;
SETPARENT (@dislocated Frnt) (NOT p (*)) TO (1* CR - @advcl) ;

SECTION

MAP @obl PPHead - ClauseRoot ;

SETPARENT Pr + VerbArgs (NOT p (*)) TO (-1* (verb) BARRIER SB) ;
SETPARENT Pr + VerbArgs (NOT p (*)) TO (1* (verb) BARRIER SB) ;
SETPARENT Pr + VerbArgs (NOT p (*)) TO (-1* (verb)) ;

SETPARENT VerbArgs (NOT p (*))
    TO (c @acl LINK 1* CB LINK 1* CR BARRIER CB OR SB) ;

SETPARENT @mark (NOT p (*)) TO (1* (ClauseRoot) OR CR) ;

SECTION

SETPARENT @root TO (@0 (*)) ;

SETPARENT @vocative + (Q) (NOT p (*)) TO (0* CR + (Q) BARRIER SB) ;
SETPARENT @vocative + $$Domain (NOT p (*)) TO (0* CR + $$Domain) ;
SETPARENT @vocative (NOT p (*)) TO (-1* ClauseRoot) ;

SETPARENT @discourse (NOT p (*))
    TO (1* @nsubj BARRIER NonJoiner - BD LINK p (*)) ;

SECTION

SETPARENT ParenSent (NOT p (*)) TO (-1* NPHead OR PPHead) ;

SETPARENT CR + QuoteSkipAcl (NOT p (*)) TO (-1* SpeakingVerb + (verb) - @acl) ;
SETPARENT CR + (Q) (NOT p (*)) TO (-1* SpeakingVerb + (verb N) - QMark BARRIER PlainC + (N) - QMark OR PlainC + (Q)) ;
SETPARENT CR + (Q) (NOT p (*)) (c QMark) TO (-1* PlainC + (N)) ;
SETPARENT CR + (Q) - HasConj - SpecialMark (NOT p (*)) TO (-1* PlainC - (QQ)) ;
SETPARENT CR + (QQ) - HasConj (NOT p (*)) TO (-1* CR + (Q)) ;
SETPARENT CR + (Q) (NOT p (*)) TO (-1* SpeakingVerb OR CR - @conj - @acl OR @root) ;
SETPARENT QMark + @ccomp (NOT p (*)) TO (-1* SpeakingVerb) ;
SETPARENT CR - @acl (NOT p (*)) TO (-1* @root) ;
MAP @conj CR IF (c @cc) (p @root) ;
MAP @ccomp CR + (Q) IF (p SpeakingVerb - (Q)) ;
MAP @ccomp CR + (Q) IF (p NonQuote) ;
MAP @ccomp CR + (QQ) IF (p (Q)) ;
MAP @advcl HasMark IF (p CR) ;
MAP @parataxis CR IF (p CR) (NEGATE c @cc) ;

SETPARENT @obl + (N) (NOT p (*)) TO (-1* QMark BARRIER CB LINK p (*)) ;

AFTER-SECTIONS

UNMAP @nsubj IF (NOT p (*)) ;
MAP @dislocated SubjAble + (Subj) ;
SETPARENT @dislocated (NOT p (*)) TO (-1* ClauseRoot - HasMark) ;

MAP @dislocated (CPen Frnt) IF (NOT p (*)) ;
SETPARENT @dislocated (NOT p (*)) TO (1* CR) ;

#UNMAP @case IF (p (verb)) ;
#MAP @mark Pr IF (p (verb)) ;

SETPARENT @nsubj OR @case (p @cop) TO (p @cop LINK p (*)) ;

REMCOHORT (pb) ;
REMCOHORT (cb) ;
REMCOHORT (sb) ;
REMCOHORT (svb) ;
#REMCOHORT (excb) ;

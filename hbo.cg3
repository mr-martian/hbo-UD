DELIMITERS = "<svb>" ;

####################
# Boundaries
####################

LIST PB = pb ;
LIST CB = cb ;
LIST SB = sb ;
LIST SVB = svb ;
LIST BD = pb cb sb svb ;
LIST Sent = ("׃" punct) ("נ" punct) ("פ" punct) ("ס" punct) ;
SET BDsent = BD OR Sent ;
LIST Joiner = ("׀" punct) ("־" punct) ;
SET NonJoiner = (*) - Joiner ;

####################
# POS
####################

LIST Det = art ;
LIST Pr = prep ;
LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;
LIST RelMark = ("אשׁר" conj @mark) ("ה" conj CP Rela) ("שׁ" conj) ;
LIST Number = card ordn ;
LIST PRON = prde prps prn ;
LIST ADJ = adjv ;
LIST ADV = advb nega ;
LIST SCONJ = "כי" "פן" "אשׁר" "אם" "שׁ" "ה" "לולא" ;

####################
# Subcategories
####################

LIST Participle = ptca ptcp ;

####################
# Text-Fabric labels
####################

# Complete

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;
LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ
LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;
LIST Domain = N D Q ? QQ ;

# Subsets

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;
LIST VerbInitial = Way0 WayX ;
LIST NonQuote = N D ? ;

####################
# Helper labels
####################

LIST HasConj = HasConj ;
LIST HasMark = HasMark ;
LIST HasRel = HasRel ;

LIST PPHead = PPHead ;
LIST NPHead = NPHead ;

LIST CR = ClauseRoot ;
LIST ClauseRoot = ClauseRoot ; # is root of clause
LIST FullClauseRoot = FullClauseRoot ; # is root of non-relative clause

SET PlainC = CR - HasMark - HasRel ;
SET PlainNC = PlainC - HasConj ;

LIST Lemma = ".*"r ;
LIST Lemma2 = ".*"r ;

LIST Q = Q ;
LIST QQ = QQ ;
LIST NQ = NQ ;
LIST QuoteLevel = NQ Q QQ ;

LIST VerbArgs = @nsubj @obj @obl @vocative (@xcomp adjv) (@advcl infa) (@advcl infc) @advmod ;

####################
# Word lists
####################

LIST NegObl = ("בלת" subs InfC) ;
LIST QMark = ("לאמר" SCONJ verb) ;

LIST CaseAbleAdv = "כן" "שׁם" "פה" "שׁם" "הלאה" "הנה" "עתה" "אז" ;

LIST FamilyOrTitle = "בן" "בת" "אב" "כלה" "אשׁה" "מלך" "גברת" "שׂר" "אחות" ;

LIST CcompVerb = "ראה" "ירא" "ידע" "נחם" "נגד" ;
LIST XcompVerb = "שׁחת" "קרא" "מלא" "לבשׁ" "שׁחת" "מהר" "יכל" "חדל" "אמץ" "כלה" ;
LIST AdvclMarkVerb = "קרא" ;
LIST PrAdvcl = "עד" ;
LIST XcompInf = "יסף" "יכל" "חפץ" "מהר" "אמץ" "חדל" "כלה" "ירא" "מלא" "חלל" "קרב" "יאל" "לאה" "צוה" ;

LIST SpeakingVerb = quot "ברך" "צוה" "נגד" "דבר" "ענה" ;

####################
# Special-case words
####################

# Apposition and NP conjunction
LIST FamilyOrTitleSkip = (Genesis w14663) ;

LIST ApposToLastGen = w265 w297 w307 w640 w648 w734 w1129 w1257 w1338 w1966 w5450 w7733 w11294 w12466 w12610 w12711 w13874 w14590 w14649 w18761 w18788 w19072 ;
LIST ApposToLastRut = w19 w50 w93 ;
SET ApposToLast = ApposToLastGen + (Genesis) OR ApposToLastRut + (Ruth) ;

LIST ApposOverride = (w93 Ruth) (w189 Genesis) (Genesis w14323) ;
LIST ConjToAppos = w36714 (w7950 Exodus) (w95 Ruth) (w215 Genesis) (w313 Genesis) (Genesis w303) (Genesis w5424) ;
LIST ConjToSmixut = (Genesis w734) ;

# @acl and @advcl
LIST MarkOverride = (Genesis w1508) (Genesis w1561) (Genesis w2064) (Genesis w2072) (Genesis w14455) (Genesis w15341) (Ruth w319) ;
LIST NonMarkOverride = (Genesis w1243) (Genesis w11173) ;
LIST NonRelOverride = (Genesis w2676) ;

LIST PreMark = (Genesis w1774) (Genesis w6030) (Genesis w6036) (Genesis w11906) (Genesis w16927) (Genesis w17650) (Genesis w28321) (Ruth w1212) (Ruth w1206) ;
LIST PostMark = (Genesis w1035) (Genesis w1231) (Genesis w2977) (Ruth w948) (Ruth w1301) (Ruth w1467) ;
LIST NestMark = (Genesis w2099) (Genesis w2760) (Genesis w13723) (Genesis w16271) (Genesis prn c32626) (Genesis w21741) (Genesis w25551) (Ruth w122) (Ruth w127) (Ruth w1161) (Ruth w1181) ;
LIST MarkToAcl = (Genesis w1848) (Genesis w19068) (Genesis w26087) (Ruth w714) ;

LIST ActuallyCcomp = (w351 Genesis) (Genesis w1037) (Genesis w1251) (Genesis w7129) (Ruth w1243) ;
LIST ActuallyAdvcl = (Genesis w16459) (Genesis w26044) (Genesis w28625) (Ruth w1161) (Ruth w1187) ;

####################
# Universal Dependencies
####################

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound = @compound ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @flat = @flat ;
LIST @flat:name = @flat:name ;
LIST @orphan = @orphan ;
LIST @dep = @dep ;       # Any remaining dependency

####################
# Special-case words
####################

LIST etNotAcc = NonAcc (Genesis w2857) (Genesis w2946) (Genesis w3165) (Genesis w3529) (Genesis w3560) (Genesis w3693) (Genesis w4172) (Genesis w4221) (Genesis w13880) (Ruth w897) (Ruth w901) (Genesis w25257) ;

########################################
# INDIVIDUAL WORDS
########################################

BEFORE-SECTIONS

####################
# Corrections
####################

LIST MislabeledAsNarrative = w1404 w1405 w1423 w1424 w14251 w14252 w14253 (Genesis s80885) (Ruth s5672) (Ruth s5673) (Genesis s83562) ;
SUBSTITUTE (N) (Q) MislabeledAsNarrative ;

LIST UnknownShouldBeNarrative = (Genesis w2137) ;
SUBSTITUTE (?) (N) UnknownShouldBeNarrative ;

####################
# Nested Quotations
####################

LIST DoubleQuoteGen = s80831 s80834 s80836 s80837 s80886 s81424 s81428 s81443 s81543 s81737 s81766 s81767 s81785 s81829 s81933 s81999 s82001 s82028 s82037 s82159 s82295 s82315 s82367 s82380 s82382 s82410 s82412 s82413 s82446 s82450 s82599 s82626 s82629 s82776 s82946 s83252 s83255 s83285 s83303 s83318 s83319 s83327 s83431 s83432 s83449 s83459 s83470 s83474 s83479 s83480 s83482 s83510 s83626 s83628 s83906 s83919 s84071 s84283 s84313 s84382 s84435 s84464 s84492 s84537 s84545 s84551 s84555 s84628 s84638 s84673 s84681 s84708 s84709 s84719 s84722 s84765 s84804 s84805 s84828 s84934 s84941 s84943 s85134 s85229 s85230 s85261 s85262 ;
SET DoubleQuote = (Genesis) + DoubleQuoteGen ;
SUBSTITUTE (Q) (QQ) DoubleQuote ;

ADD NQ (*) - QuoteLevel ;

####################
# MWE names
####################

SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בית" wp1) ;
SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בן" wp1) ;
SUBSTITUTE (nmpr) (subs retag:nmpr m) ("אל" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("לחם" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("צדק" wp2) ;
SUBSTITUTE ("מלכי" nmpr) ("מלך" subs c retag:nmpr) (wp1 Genesis w6557) ;
SUBSTITUTE ("עמי" nmpr) ("עם" subs retag:nmpr has_prn) ("עמי" wp2) ;
SUBSTITUTE ("אוני" nmpr) ("און" subs retag:nmpr has_prn) ("אוני" wp2) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("עם" subs retag:nmpr) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("און" subs retag:nmpr) ;

MAP @flat:name (nmpr wp2) IF (-1* (nmpr wp1) BARRIER NonJoiner) ;
SETPARENT @flat:name TO (-1* (nmpr wp1)) ;

####################
# Retagging
####################

# quotation
MERGECOHORTS ("<le'emor>" "$2$1"v SCONJ *) ("(אמר)"r verb infc) WITH (-1 ("(ל)"r prep)) ;

# Substantivized adjectives
SUBSTITUTE (adjv) (subs retag:adjv) (c) ;
SUBSTITUTE (adjv) (subs retag:adjv) (a) (1 BD) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv a) (1 (prn)) ;
# TODO: does this really apply to all gentillics?
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl pl) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (NEGATE 0* (subs) OR (nmpr) BARRIER PB) ;

# Participles in smixut
LIST NPish = NP PP ;
SUBSTITUTE (verb) (subs retag:verb) Participle + NPish ;

# Adverbs tagged subs
SUBSTITUTE (subs) (advb retag:subs) (padv) - (NP) (-1 BD) (1* BD BARRIER (*) - (punct)) ;

# Determiner on clause participles
SUBSTITUTE (art) (conj retag:art) (CP Rela) ;

# Prepositions tagged as nouns
SUBSTITUTE (subs) (advb retag:subs) ("אחר" subs ppre AdvP) (1 BD) ;
SUBSTITUTE (subs) (prep retag:subs) ("אחר" subs ppre) ;

# yesh and ein
SUBSTITUTE (subs) (verb retag:subs ClauseRoot) (nmcp) ;

# interrogative adverbs
LIST ItgAdv = "מתי" "איפה" "איך" "אן" "מדוע" ;
SUBSTITUTE (inrg) (advb retag:inrg) ItgAdv ;

# interjections
SUBSTITUTE (conj) (intj retag:conj) ("לו") ;

####################
# Helper labels
####################

ADD (NonAcc) ("את" prep Cmpl) + $$ClauseType - (NonAcc)
    IF (0* ("את" prep Objc) + $$ClauseType BARRIER SB) ;

####################
# Consistent labels
####################

MAP @punct (punct) ;
MAP @det Det ;
MAP @mark SCONJ + (conj CP) ;
MAP @mark ("ה" inrg) ;
MAP @obj ("את") + Pr IF (1 RelMark) ;
MAP @obl Pr IF (1* RelMark BARRIER NonJoiner) ;
MAP @case Pr ;
MAP @cc (conj) - (Rela) ;
MAP @advmod ADV - (ClausePhraseRoot) ;
MAP @advmod ADV + (MSyn) ;
MAP @advmod ADV IF (0* NonJoiner - BD BARRIER BD) ;
MAP @advmod ("למה" inrg) ;
MAP @discourse (intj) ; # TODO: is there a better way to handle הנה?

####################
# Pronoun suffixes
####################

SUBSTITUTE ("prn") ("אני") ("prn" prn p1 sg) ;
SUBSTITUTE ("prn") ("אנחנו") ("prn" prn p1 pl) ;
SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("את") ("prn" prn p2 f sg) ;
SUBSTITUTE ("prn") ("אתם") ("prn" prn p2 m pl) ;
SUBSTITUTE ("prn") ("אתן") ("prn" prn p2 f pl) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("היא") ("prn" prn p3 f sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;
SUBSTITUTE ("prn") ("הן") ("prn" prn p3 f pl) ;

########################################
# PHRASES
########################################

SECTION

####################
# Pronoun suffixes
####################

LIST NsubjPrn = ExsS ModS NCoS PrcS PreS ;
LIST ObjPrn = PreO PtcO ;
MAP @nsubj (prn) + NsubjPrn ;
MAP @obj (prn) + ObjPrn ;
MAP @obj (prn) IF (-1 (verb)) ;
MAP (NPHead @obj) (prn Objc) IF (-1 Pr + ("את") - etNotAcc) ;
SETPARENT (prn @obj) OR (prn @nsubj) (NOT p (*)) TO (-1 (verb)) ;
MAP @nmod:poss (prn) IF (-1 Noun - (verb) - Number) ;
SETPARENT @nmod:poss (NOT p (*)) TO (-1 Noun) ;
MAP @nmod (prn) IF (-1 Number) ;
SETPARENT (prn @nmod) (NOT p (*)) TO (-1 Number) ;

####################
# Numbers
####################

LIST BigNumber = "עשׂרה" "מאה" "עשׂר" ;
MAP @flat BigNumber + Number IF (-1* Number BARRIER NonJoiner) ;
SETPARENT @flat + Number (NOT p (*)) TO (-1* Number BARRIER NonJoiner) ;
MAP @conj Number IF (-1* @cc BARRIER NonJoiner LINK -1* Number BARRIER NonJoiner - @flat) ;
SETPARENT @cc (NOT p (*)) TO (1 Number + @conj) ;
#SETPARENT Number (NOT p (*)) TO (1 (prn)) ;
SETPARENT Number + @conj (NOT p (*))
    TO (-1* Number - @flat BARRIER NonJoiner - @cc - @flat) ;
SETPARENT Number + (c) (NOT p (*)) TO (1* Noun - Number BARRIER NonJoiner - Det) ;
SETPARENT Number (NOT p (*)) TO (-1 Noun - Number) ;
SETPARENT Number (NOT p (*))
    TO (1* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
SETPARENT Number (NOT p (*))
    TO (0* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
MAP @nummod Number IF (p Noun OR (prn)) (NEGATE c @nmod) ;

####################
# Smixut
####################

# conjunction within smixut
# (kinda weird, but arg structure doesn't make sense otherwise)
MAP @conj $$Lemma + (subs) IF (-1* NonJoiner LINK 0 @cc LINK -1* NonJoiner - (prn) LINK 0 $$Lemma + (subs)) ;
SETPARENT @conj + $$Lemma + (subs) (NOT p (*))
    TO (-1* NonJoiner LINK 0 @cc LINK -1* NonJoiner - (prn) LINK 0 $$Lemma + (subs)) ;
SETPARENT @cc (NOT p (*)) TO (1 (subs @conj)) ;

MAP @compound:smixut Noun OR ADJ IF (-1* Noun + (c) - Number BARRIER NonJoiner - Det - @nummod - @flat) ;
SETPARENT @compound:smixut (NOT p (*)) TO (-1* Noun) ;

####################
# Determiners
####################

SET DetAble = Noun OR ADJ OR PRON ;
SETPARENT Det (NOT p (*)) TO (1 DetAble) ;
LIST PrnMaybeDet = prde (prps p3) ;
MAP @det PrnMaybeDet IF (-1 Det LINK -1* Noun BARRIER NonJoiner) ;
SETPARENT @det (NOT p (*)) TO (-1* Noun BARRIER NonJoiner - Det) ;

####################
# Adjectives
####################

SET AdjNonBar = NonJoiner - (nega) ;
SETPARENT (nega) (NOT p (*)) TO (1* ADJ BARRIER NonJoiner) ;
MAP @conj ADJ IF (-1* @cc BARRIER AdjNonBar LINK -1* ADJ BARRIER AdjNonBar) ;
MAP @conj ADJ IF (-1* ADJ BARRIER AdjNonBar)
                 (1* @cc BARRIER AdjNonBar LINK 1* ADJ BARRIER AdjNonBar) ;
SETPARENT ADJ + @conj (NOT p (*))
    TO (-1* ADJ - @conj BARRIER AdjNonBar - @cc) ;
SETPARENT @cc (NOT p (*)) (-1* ADJ BARRIER NonJoiner) TO (1* ADJ BARRIER AdjNonBar) ;

SETPARENT ADJ + $$AGen + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$AGen + $$ANum + $$ADet BARRIER PB OR Pr) ;
SETPARENT ADJ + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$ANum + $$ADet - AGen BARRIER PB OR Pr) ;
MAP @amod ADJ IF (p Noun) ;

LIST BetterHeads = Pred Subj Objc PreC PreO ;
UNMAP @advmod IF (NOT 0 (MSyn)) (NEGATE 0* BetterHeads BARRIER SB) ;
LIST AdvIsh = (advb AdvP) (nega NegP) ;
ADD CR AdvIsh - CR ;

####################
# Prepositions
####################

LIST NumberLabel = @nummod @conj @flat ;
SET ProbablyNumber = Number + NumberLabel ;
SET CaseAble = Noun - ProbablyNumber OR PRON OR (verb infc) - QMark OR (verb infa) OR CaseAbleAdv + ADV OR (prin) OR (inrg);
SET AfterPrep = Det OR @case OR @nummod OR @cc OR ProbablyNumber ;
SETPARENT @case (NOT p (*)) TO (1* CaseAble BARRIER NonJoiner - AfterPrep) ;
SETPARENT @case (NOT p (*)) TO (1*A ADJ BARRIER NonJoiner - AfterPrep LINK NOT p (*)) ;

####################
# Label NP heads
####################

ADD PPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead) (c @case - ("את") OR etNotAcc) ;
ADD NPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead OR NPHead) ;

####################
# NP/PP conjunctions
####################

SETPARENT REPEAT @cc (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;
ADD REPEAT HasConj NPHead OR PPHead IF (NOT 0 HasConj) (c @cc) ;

####################
# NP/PP adverbs
####################

LIST NPIsh = NP PPrP PP PrNP PreO ;
SETPARENT @advmod + NPIsh (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;

####################
# Apposition
####################

MAP REPEAT @appos NPHead - HasConj - (nmpr) IF (-1* NPHead OR PPHead BARRIER BD) ;
LIST Titles = "בכר" ;
MAP REPEAT @appos NPHead - HasConj + (nmpr) IF (-1* NPHead + Titles BARRIER BD OR NPHead OR PPHead) ;

####################
# VP
####################

MAP @obl NegObl IF (1* (infc) BARRIER NonJoiner) ;
SETPARENT NegObl (NOT p (*)) TO (1* (infc) BARRIER NonJoiner) ;

MAP @acl (verb infc VP) IF (-1 (subs c) - NegObl) ;
SETPARENT (verb infc VP @acl) (NOT p (*)) TO (-1 (subs c)) ;

SETPARENT @cc (NOT p (*)) (-1 (infa)) TO (1 (infa)) ;
MAP @conj (infa) IF (c @cc) ;
SETPARENT (infa) (NOT p (*)) (c @cc) TO (-2 (infa)) ;
MAP @advcl (infa AdvP) IF (NOT 1 BD) ;

LIST Inf = (infc InfC) PrepVerb ;

####################
# Connect NPs
####################

SET NonAppos = NPHead - @appos ;

MAP REPEAT @conj PPHead + HasConj IF (-1* PPHead BARRIER BD OR NonAppos) ;
MAP REPEAT @conj PPHead IF (-1* PPHead BARRIER BD OR NonAppos)
                           (1* PPHead + HasConj BARRIER BD OR NonAppos) ;

SECTION
SETPARENT PPHead + @conj (NOT p (*))
    TO (-1* PPHead - @conj BARRIER BD OR NonAppos) ;

SECTION
MAP @appos ApposOverride;
SETPARENT CaseAble + ConjToAppos TO (-1* @appos) ;
SETPARENT CaseAble + ConjToSmixut TO (-1* @compound:smixut) ;
MAP @conj NPHead + HasConj IF (-1* NonAppos BARRIER BD) ;
MAP @conj NPHead IF (-1* NonAppos BARRIER BD) (1* NPHead + HasConj BARRIER BD) ;
SETPARENT NPHead + @conj (NOT p (*)) TO (-1* NonAppos - @conj BARRIER BD) ;

# TODO: any better way to do this?
SETPARENT (w189 Genesis) (NOT p (*)) TO (-1* (w185)) ;
SETPARENT (Genesis w14323) (NOT p (*)) TO (-1* (prn)) ;

SETPARENT FamilyOrTitle + (subs) - FamilyOrTitleSkip (NOT p (*))
    TO (-1* (nmpr a) - (topo) BARRIER NonJoiner) ;

LIST ApposAble = subs nmpr prn ;
SETPARENT CaseAble + ApposToLast (NOT p (*)) TO (-1* ApposAble - (wp2)) ;
SETPARENT CaseAble - ApposToLast - ConjToAppos (NOT p (*))
     TO (-1* BD LINK 1*A CaseAble - @compound:smixut BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP KEEPORDER @appos CaseAble IF (c @case + $$Lemma) (p CaseAble LINK c @case + $$Lemma) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @appos CaseAble IF (p CaseAble) ;

SETPARENT PPHead (NOT p (*)) TO (-1* NPHead BARRIER PB) ;
MAP @nmod PPHead IF (p NPHead) ;

LIST NorP = NPHead PPHead ;
SETPARENT NPHead + @appos (NOT p (*)) TO (-1* NorP - @appos BARRIER BD) ;

SETPARENT (/^\(c\\d+\)$/r) + (Objc HasConj) (NOT p (*)) TO (-1* (VSTR:$1) + (NPHead Objc) - HasConj - @appos) ;

####################
# Other labels
####################

MAP @cop (vbcp) + $$ClauseType OR (aux nmcp) IF (0* (PreC) + $$ClauseType BARRIER SB) ;
SETPARENT @cop + $$ClauseType (NOT p (*)) TO (0* (PreC) + $$ClauseType + NorP - @conj BARRIER SB) ;

SECTION # conjunction

SETPARENT (conj PP) (NOT p (*)) TO (1* (subs PP)) ;
MAP @conj (subs PP) - (PreC) - CR IF (0 (subs) LINK c @cc) (NOT c @cop) ;
LIST CorC = (@conj) (@compound:smixut) ;
SETPARENT ("בין" subs PP @conj) TO (-1* ("בין" subs PP) - @conj) ;
SETPARENT (subs PPHead @conj) - CR (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;
MAP @conj (subs NP) IF (0 (subs) LINK c @cc - (CP)) ;

SECTION # helper labels

TEMPLATE CRp = (NOT 0 CR LINK NEGATE 0* CR BARRIER CB) ;

ADD CR (ClausePhraseRoot) - CR + (/^(c\\d+\)$/r) - QMark IF (NEGATE -1* (VSTR:$1) + CR) ;

# irregular conjunction attachment
#SETPARENT (Genesis w11903) (NOT p (*)) TO (1* (Genesis w11910)) ;
LIST ConjSkipClause = (Genesis w1771) (Genesis w11903) ;
SETPARENT ConjSkipClause (NOT p (*)) TO (1* CR LINK 1* CR) ;

####################
# Blah
####################

SETPARENT (Genesis w1251) (NOT p (*)) TO (-1* CR LINK -1* CR) ;
SETPARENT (Genesis w1256) (NOT p (*)) TO (-1* CR) ;

####################
# Attach by clause label
####################

LIST NoGlom = prep ;

SETPARENT (/^\(c\\d+\)$/r) - CR - NoGlom (NOT p (*)) TO (0* (VSTR:$1) + CR) ;

LIST SubjIsh = Subj (IntS prn) ;
MAP @nsubj SubjIsh - CR IF (p CR LINK NEGATE c @nsubj) ;
MAP @dislocated (Subj) - CR IF (p CR) ;
MAP @obj (Objc) - CR IF (p CR LINK NEGATE c @obj) ;
MAP @xcomp (Objc) - CR OR (PrAd) - CR IF (p CR) ;

MAP @advmod (verb infa) + $$Lemma - CR IF (p CR + $$Lemma) ;

LIST OblIsh = Time Cmpl Loca Modi Adju Supp (Conj PPHead) ;
MAP @orphan OblIsh + (Ellp) - CR IF (p CR + (Ellp)) ;
MAP @obl OblIsh - CR IF (p CR) ;

ADD CR (Pred) - (vbcp) - CR - QMark ;
LIST PredIsh = PreC PrcS PrAd PreO PreS PtcO ;
ADD CR PredIsh IF (T:CRp) ;
LIST CopIsh = (Pred vbcp) NCop NCoS ;
LIST NonCopIsh = (Genesis w1955) ;
ADD CR CopIsh - NonCopIsh IF (T:CRp) ;

LIST OrphanPrepVerb = (Genesis w18716) ;
ADD (PrepVerb) (verb) - (PrepVerb) - OrphanPrepVerb IF (c @case OR ("בלת" @obl)) ;
ADD (PrepVerb) (*) - (PrepVerb) IF (c @cop LINK c @case) ;

SECTION # clause con

ADD HasConj CR - HasConj IF (c @cc) ;
ADD HasMark CR - HasMark + (infc) IF (c @case) ;
ADD HasMark CR + (PrepVerb) - HasMark ;
ADD HasMark CR - HasMark - NonMarkOverride IF (c @mark - (inrg ques) - QMark - (Rela) - RelMark) ;
ADD HasMark CR + MarkOverride - HasMark ;
ADD HasRel CR - HasRel - NonRelOverride IF (c @mark + (Rela) OR RelMark) ;

SECTION

SETPARENT (HasMark HasConj) (NOT p (*))
    TO (-1* HasMark - HasConj BARRIER PlainC) ;
MAP @conj (HasMark HasConj) - NestMark IF (p HasMark) ;

LIST Ptc = ptcp ptca infc ;

SETPARENT (verb) + Ptc - QMark (NOT p (*)) TO (-1* Noun - @compound:smixut BARRIER NonJoiner - BD - @det - @compound:smixut) ;
MAP @acl (verb) + Ptc - QMark IF (p Noun) ;

MAP @xcomp (verb infc InfC) - QMark IF (-1* XcompInf + (verb) BARRIER SB OR @mark) ;

MAP @xcomp (NPHead PreC) IF (0* (vbcp infc InfC) BARRIER CB LINK -1* XcompInf + (verb) BARRIER SB OR @mark) ;
MAP @cop (vbcp) IF (p (PreC)) ;

SETPARENT (@xcomp InfC) (NOT p (*)) TO (-1* XcompInf + (verb) BARRIER SB) ;

MAP @cop (vbcp) IF (1* Participle OR (infc) BARRIER (*) - BD - ("ל" prep)) ;
SETPARENT @cop (NOT p (*)) TO (1* Participle OR (infc) BARRIER (*) - BD - ("ל" prep)) ;

MAP @advcl (infc) IF (-1 ("ל" prep) LINK -1* (verb nmcp) BARRIER SB) ;
MAP @xcomp Participle - (Subj) IF (-1* (verb nmcp) BARRIER SB) ;
SETPARENT @advcl OR @xcomp (NOT p (*)) TO (-1* (verb nmcp) BARRIER SB) ;

SECTION

SETPARENT MarkToAcl (NOT p (*)) TO (0* CR + HasRel) ;
SETPARENT NestMark (NOT p (*)) TO (0* CR + HasMark) ;
SETPARENT PreMark (NOT p (*)) TO (1* CR - HasMark) ;
SETPARENT PostMark (NOT p (*)) TO (-1* CR - HasMark) ;
SETPARENT HasMark (NOT p (*))
    TO (0* PlainC BARRIER CR - HasMark - HasRel OR SB OR ("ה" inrg)) ;


LIST AdvclAble = ("כי" conj @mark) ("אם" conj @mark) ;

SETPARENT QMark (NOT p (*))
    TO (1* (FullClauseRoot Q) OR (FullClauseRoot QQ)) ;

SET SpecialMark = MarkToAcl OR NestMark OR PreMark OR PostMark ;
SETPARENT CR + $$Domain - SpecialMark (c AdvclAble) (NOT p (*))
    TO (-1* PlainC + $$Domain BARRIER Domain - $$Domain) ;
SETPARENT (verb infc) + $$Domain - QMark (NEGATE c @cc) (NOT p (*))
    TO (-1* CR + $$Domain BARRIER Domain - $$Domain) ;

MAP @ccomp ActuallyCcomp ;
MAP @advcl ActuallyAdvcl ;
MAP @advcl CR IF (c PrAdvcl + @case) ;
MAP @advcl CR IF (c AdvclAble) (p AdvclMarkVerb) ;
MAP @xcomp CR IF (c AdvclAble) (p XcompVerb) ;
MAP @xcomp CR IF (c AdvclAble) (p CcompVerb LINK c @obj) ;
MAP @ccomp CR IF (c AdvclAble) (p CcompVerb) ;
MAP @advcl CR IF (c AdvclAble) (p (*)) ;
MAP @advcl (PrepVerb) IF (p (*)) ;

LIST OrphanInfc = (Genesis w18716) ;
MAP @advcl CR + HasMark - OrphanInfc IF (p CR) ;

SETPARENT @ccomp (NOT p (*)) TO (0* CcompVerb BARRIER SB) ;

ADD FullClauseRoot PlainC - @acl - FullClauseRoot ;

SECTION

SETPARENT FullClauseRoot + HasConj + $$Domain (NOT p (*))
    TO (-1* FullClauseRoot - HasConj + $$Domain BARRIER FullClauseRoot - $$Domain) ;

MAP @conj FullClauseRoot + HasConj IF (p FullClauseRoot) ;

MAP @conj Inf IF (c @cc LINK -1* Inf BARRIER SB OR CR - Inf) ;
SETPARENT Inf + @conj (NOT p (*))
    TO (c @cc LINK -1* Inf - @conj BARRIER SB OR CR - Inf) ;

SECTION # adjacent words

LIST SmallQstQ = inrg prin ;
LIST SmallQstPrn = prde prn ;
MAP @nsubj SmallQstQ - CR IF (-1 BD) (1* SmallQstPrn BARRIER NonJoiner LINK 1 BDsent) ;

SECTION # phrase-internal structure

ADD (ClauseRoot) (adjv AjCl) - (ClauseRoot) IF (NOT p (*)) ;
LIST AdjNonAcl = (Genesis w23609) ;
MAP @acl (ClauseRoot AjCl) - AdjNonAcl
    IF (-1* CB BARRIER SB OR @mark LINK -1* NPHead BARRIER BD) ;

####################
# Label verb arguments
####################

SECTION

### SUBJECTS

LIST SubjAble = subs prps nmpr prde prn prin ;
MAP @nsubj SubjAble + (Subj) - CR ;

MAP @nsubj SubjAble + (Subj NmCl ClausePhraseRoot)
    IF (1* CR + HasRel BARRIER CR) ;
SETPARENT @nsubj + (NmCl ClausePhraseRoot) (NOT p (*))
    TO (1* CR + HasRel BARRIER CR) ;

LIST CsubjOverride = (Genesis w1006) ;
MAP @csubj CsubjOverride ;
SETPARENT @csubj (NOT p (*)) TO (0* CR BARRIER SB) ;

### OBJECTS

LIST ObjAble = subs prn nmpr prin prde ;
ADD REPEAT (ProbablyObj) ObjAble + (Objc) - (ProbablyObj) ;
ADD REPEAT CR (ProbablyObj Ellp) - CR ;

LIST ObjIsh = @obj ProbablyObj ;
LIST XcompOverride = (Genesis w17124) ;
MAP @xcomp XcompOverride ;
MAP @obj (ProbablyObj) + $$ClauseType - CR IF (NEGATE -1* ObjIsh + $$ClauseType BARRIER SB) ;

### OBLIQUES

MAP @obl Noun + (Adju a) ;
MAP @obl PPHead + (PreC) IF (-1* (nmcp) BARRIER SB) ;
MAP @obl Noun + OblIsh - CR ;

MAP @vocative Noun + (Voct) ;

####################
# Attach verb arguments
####################

SECTION

SET NonNmCl = (*) - (NmCl) - (prn) ;

MAP @acl (ClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
LIST AclChain = (Genesis w603) ;
SETPARENT @acl + AclChain (NOT p (*)) TO (-1* @acl LINK p (*)) ;
SETPARENT (subs @acl) - AclChain (NOT p (*)) TO (-1* Noun - (verb) OR Pr + @obj OR Pr + @obl) ;

LIST RelSkip = (Ruth w550) ;
SETPARENT @acl (NOT p (*)) TO (-1* NorP - RelSkip BARRIER SB) ;

SECTION

SETPARENT VerbArgs + $$ClauseType - Pr (NOT p (*))
    TO (0* CR + $$ClauseType BARRIER SB) ;

SECTION

SETPARENT (conj CP) (NOT p (*)) TO (1 PB LINK 1 @cop LINK p (*)) ;
SET CorR = (conj CP) OR RelMark ;
SET CorM = CR OR (nmcp) - @cop ;
LIST ConjTypes = CPen NmCl MSyn ;
SETPARENT CorR + $$ClauseType (NOT p (*)) TO (1* CorM + $$ClauseType) ;
MAP @acl CR IF (c RelMark) (NEGATE c (@nsubj NmCl)) ;
LIST AclAble = subs adjv ptcp ptca nmpr ;
LIST AclCompOk = (Exodus w3801) (Exodus w5417) ;
LIST AclCompNotOk = (Genesis w1179) (Genesis w12528) (Genesis w12613) (Ruth w712) ;
LIST AclMultiTarget = (Genesis w391) ;
SETPARENT @acl (NOT p (*)) TO (-1* AclMultiTarget BARRIER SB) ;
SETPARENT @acl (NOT p (*)) TO (c @mark LINK -1* Pr BARRIER NonJoiner) ;
SETPARENT @acl + AclCompNotOk (NOT p (*))
    TO (-1* CB LINK -1* AclAble - @compound:smixut BARRIER BD) ;
SETPARENT @acl - AclCompNotOk - AclChain (NOT p (*))
    TO (-1* CB LINK -1* AclAble - @nummod BARRIER BD) ;

MAP @advmod (verb infa) IF (1* PB BARRIER NonJoiner LINK 1 (verb)) ;

MAP @ccomp QMark IF (NEGATE 1* CR) ;
MAP @mark QMark ;

SECTION




LIST XorO = (@xcomp ProbablyObj) @obj ;
SETPARENT XorO + $$ClauseType (NOT p (*))
    TO (0* CR + $$ClauseType BARRIER SB) ;

ADD CR (*) - CR IF (c @nsubj) ;

SECTION

LIST PrepVerbChain = (Genesis w13720) (Genesis w16269) ;

SETPARENT (PrepVerb) (NOT p (*))
    TO (0* CR - (PrepVerb) OR PrepVerbChain BARRIER SB) ;
MAP @advcl (PrepVerb) IF (p (*)) ;

ADD CR NPHead OR PPHead IF (c @mark) ;
SETPARENT CorR + ConjTypes + @mark (NOT p (*)) TO (1* CorM - @acl) ;

MAP @advcl (ClauseRoot Q HasMark)
    IF (c @mark - (inrg ques) - QMark) (1* (ClauseRoot Q) BARRIER NonQuote LINK NEGATE c @mark) ;
MAP (ClauseRoot @ccomp) (subs ClauseRoot)
    IF (c (vbcp infc Pred)) (NOT -1* @ccomp) ;
SET MSynIsh = CorR + @cc OR @advmod ;
SETPARENT MSynIsh + ConjTypes (NOT p (*)) TO (1* CorM - @advcl - @acl) ;
MAP @conj (ClauseRoot Q)
    IF (c @cc) (-1* (ClauseRoot Q) - @acl - @advcl BARRIER (N)) ;
MAP @parataxis (ClauseRoot Q) - (infc) - HasMark - HasConj
    IF (NEGATE c @cc) (NEGATE c @mark)
       (-1* (ClauseRoot Q) - @acl - @advcl - (HasMark @conj) BARRIER (N)) ;
MAP @ccomp (ClauseRoot Q)
    IF (NEGATE c @mark) (-1* CR + NonQuote)
       (NOT -1* (ClauseRoot Q) - @acl BARRIER (N)) ;
LIST CRconj = @ccomp @root @parataxis ;
SETPARENT (ClauseRoot Q HasConj) - HasMark (NOT p (*))
    TO (-1* PlainNC + (Q) BARRIER CR + NonQuote) ;
SETPARENT (ClauseRoot Q @conj) (NOT p (*))
    TO (-1* (ClauseRoot Q) + CRconj) ;

MAP @root CR IF (NOT -1* CR - @advcl - @acl) ;

SETPARENT @advcl + $$Domain (NOT p (*)) TO (1* CR + $$Domain BARRIER SB) ;
SETPARENT @advcl + $$Domain (NOT p (*)) TO (-1* CR + $$Domain BARRIER SB) ;
SETPARENT @advcl + $$Domain (NOT p (*)) (NEGATE 0* CR BARRIER SB) TO (1* CR + $$Domain - @advcl) ;

SETPARENT (@ccomp Q) (NOT p (*)) TO (-1* (quot ClauseRoot) - @mark) ;
LIST CcompAble = "חלל" "נתן" "מהר" "צוה" "שׁמע" ;
SETPARENT @ccomp (NOT p (*)) TO (-1* CcompAble + CR) ;

LIST ClauseCon = @conj @parataxis @xcomp ;
MAP (@conj ClauseRoot) CR + $$NonQuote IF (-1* CR + $$NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) CR + $$NonQuote - (PrepVerb) IF (-1* CR + $$NonQuote) ;

LIST ConjToAdvcl = (Genesis w772) ;
LIST ConjToAcl = (Genesis w845) ;
SETPARENT ConjToAdvcl (NOT p (*)) TO (-1* CR + @advcl) ;
SETPARENT ConjToAcl (NOT p (*)) TO (-1* @acl) ;

LIST DontConj = @conj @acl @nmod @xcomp @appos @advcl @nmod:poss (@ccomp N) @obl @mark HasConj @csubj ;
SETPARENT CR + ClauseCon + $$Domain (NOT p (*)) TO (-1* CR + $$Domain - DontConj) ;

SECTION

MAP @dislocated SubjAble + (CPen) ;
SETPARENT (@dislocated Frnt) (NOT p (*)) TO (-1* @mark BARRIER (*) - BD LINK p (*)) ;
SETPARENT (@dislocated Frnt) (NOT p (*)) TO (1* CR - @advcl) ;

SECTION

MAP @obl PPHead - ClauseRoot ;

MAP @xcomp (NPHead adjv) - FullClauseRoot ;

SETPARENT Pr + VerbArgs (NOT p (*)) TO (-1* (verb) BARRIER SB) ;
SETPARENT Pr + VerbArgs (NOT p (*)) TO (1* (verb) BARRIER SB) ;
SETPARENT Pr + VerbArgs (NOT p (*)) TO (-1* (verb)) ;

SETPARENT @nsubj (NOT p (*)) TO (0* @cop BARRIER CB LINK p (*)) ;

SETPARENT VerbArgs (NOT p (*))
    TO (c @acl LINK 1* CB LINK 1* CR BARRIER CB OR SB) ;

SETPARENT VerbArgs + $$ClauseType (NOT p (*))
    TO (0* CR + $$ClauseType BARRIER SB) ;

SETPARENT @mark (NOT p (*)) TO (1* (ClauseRoot) OR CR) ;

SECTION

SETPARENT @root TO (@0 (*)) ;

SETPARENT @vocative + (Q) (NOT p (*)) TO (0* CR + (Q) BARRIER SB) ;
SETPARENT @vocative + $$Domain (NOT p (*)) TO (0* CR + $$Domain) ;
SETPARENT @vocative (NOT p (*)) TO (-1* ClauseRoot) ;

SETPARENT @discourse (NOT p (*))
    TO (1* @nsubj BARRIER NonJoiner - BD LINK p (*)) ;
SETPARENT @discourse (NOT p (*)) TO (1* (verb) BARRIER (*) - PB - CB) ;

SECTION

SETPARENT CR + (Q) (NOT p (*)) (c QMark) TO (-1* SpeakingVerb BARRIER PlainC + (N) - QMark) ;
SETPARENT CR + (Q) (NOT p (*)) (c QMark) TO (-1* PlainC + (N)) ;
SETPARENT CR + (Q) - HasConj - SpecialMark (NOT p (*)) TO (-1* PlainC - (QQ)) ;
SETPARENT CR + (QQ) - HasConj (NOT p (*)) TO (-1* CR + (Q)) ;
SETPARENT CR + (Q) (NOT p (*)) TO (-1* SpeakingVerb OR CR - @conj OR @root) ;
SETPARENT QMark + @ccomp (NOT p (*)) TO (-1* SpeakingVerb) ;
SETPARENT CR - @acl (NOT p (*)) TO (-1* @root) ;
MAP @conj CR IF (c @cc) (p @root) ;
MAP @ccomp CR + (Q) IF (p SpeakingVerb - (Q)) ;
MAP @ccomp CR + (Q) IF (p (N)) ;
MAP @ccomp CR + (QQ) IF (p (Q)) ;
MAP @parataxis CR IF (p CR) (NEGATE c @cc) ;

AFTER-SECTIONS

UNMAP @nsubj IF (NOT p (*)) ;
MAP @dislocated SubjAble + (Subj) ;
SETPARENT @dislocated (NOT p (*)) TO (-1* ClauseRoot - HasMark) ;

#UNMAP @case IF (p (verb)) ;
#MAP @mark Pr IF (p (verb)) ;

REMCOHORT (pb) ;
REMCOHORT (cb) ;
REMCOHORT (sb) ;
REMCOHORT (svb) ;
REMCOHORT (excb) ;

DELIMITERS = "<sb>" ;

####################
# Boundaries
####################

LIST PB = pb ;
LIST CB = cb ;
LIST SB = sb ;
LIST BD = pb cb sb ;
LIST Sent = ("׃" punct) ("נ" punct) ("פ" punct) ("ס" punct) ;
SET BDsent = BD OR Sent ;

####################
# POS
####################

LIST Det = art ;
LIST Pr = prep ;
LIST Joiner = ("׀" punct) ("־" punct) ;
SET NonJoiner = (*) - Joiner ;
LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;
LIST RelMark = ("אשׁר" conj @mark) ;
LIST Number = card ordn ;
LIST PRON = prde prps prn ;
LIST ADJ = adjv ;
LIST ADV = advb nega ;

####################
# Text-Fabric labels
####################

# Complete

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;
LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ
LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;
LIST Domain = N D Q ? ;

# Subsets

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;
LIST VerbInitial = Way0 WayX ;

####################
# Helper labels
####################

LIST HasConj = HasConj ;

LIST PPHead = PPHead ;
LIST NPHead = NPHead ;

LIST MaybeClauseRoot = MaybeClauseRoot ; # could be root of some clause
LIST ClauseRoot = ClauseRoot ; # is root of clause
LIST FullClauseRoot = FullClauseRoot ; # is root of non-relative clause
LIST TopClauseRoot = TopClauseRoot ; # is root of non-quoted clause

####################
# Universal Dependencies
####################

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound = @compound ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @flat = @flat ;
LIST @dep = @dep ;       # Any remaining dependency

########################################
# INDIVIDUAL WORDS
########################################

BEFORE-SECTIONS

####################
# Corrections
####################

LIST MislabeledAsNarrative = w14251 w14252 w14253 ;
SUBSTITUTE (N) (Q) MislabeledAsNarrative ;

####################
# Retagging
####################

# Substantivized adjectives
SUBSTITUTE (adjv) (subs retag:adjv) (c) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv a) (1 (prn)) ;
# TODO: does this really apply to all gentillics?
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl pl) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (-1* Noun + (c) BARRIER NonJoiner - Det) ;

# Participles in smixut
LIST Participle = ptca ptcp ;
LIST NPish = NP PP ;
SUBSTITUTE (verb) (subs retag:verb) Participle + NPish ;

####################
# Consistent labels
####################

MAP @punct (punct) ;
MAP @det Det ;
MAP @case Pr ;
LIST SCONJ = "כי" "פן" "אשׁר" "אם" "שׁ" ; # TODO: double check שׁ which only appears once
MAP @mark SCONJ + (conj CP) ;
MAP @mark ("ה" inrg) ;
MAP @cc (conj) - (Rela) ;
MAP @advmod ADV ;
MAP @advmod ("למה" inrg) ;
MAP @discourse (intj) ; # TODO: is there a better way to handle הנה?

####################
# Pronoun suffixes
####################

SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;

########################################
# PHRASES
########################################

SECTION

####################
# Numbers
####################

LIST BigNumber = "עשׂרה" "מאה" ;
MAP @flat BigNumber + Number IF (-1* Number BARRIER NonJoiner) ;
SETPARENT @flat + Number (NOT p (*)) TO (-1* Number BARRIER NonJoiner) ;
MAP @conj Number IF (-1* @cc BARRIER NonJoiner LINK -1* Number BARRIER NonJoiner - @flat) ;
SETPARENT @cc (NOT p (*)) TO (1 Number + @conj) ;
SETPARENT Number + @conj (NOT p (*))
    TO (-1* Number - @flat BARRIER NonJoiner - @cc - @flat) ;
SETPARENT Number (NOT p (*))
    TO (1* Noun - Number BARRIER NonJoiner - Det - Number) ;
SETPARENT Number (NOT p (*))
    TO (0* Noun - Number BARRIER NonJoiner - Det - Number) ;
MAP @nummod Number IF (p Noun) ;

####################
# Smixut
####################

MAP @compound:smixut Noun IF (-1* Noun + (c) - @nummod BARRIER NonJoiner - Det - @nummod) ;
SETPARENT @compound:smixut (NOT p (*)) TO (-1* Noun) ;

####################
# Determiners
####################

SET DetAble = Noun OR ADJ OR PRON ;
SETPARENT Det (NOT p (*)) TO (1 DetAble) ;
LIST PrnMaybeDet = prde (prps p3) ;
MAP @det PrnMaybeDet IF (-1 Det LINK -1* Noun BARRIER NonJoiner) ;
SETPARENT @det (NOT p (*)) TO (-1* Noun BARRIER NonJoiner - Det) ;

####################
# Adjectives
####################

SETPARENT (nega) (NOT p (*)) TO (1* ADJ BARRIER NonJoiner) ;
MAP @conj ADJ IF (-1* @cc BARRIER NonJoiner - (nega) LINK -1* ADJ) ;
SETPARENT ADJ + @conj (NOT p (*)) TO (-1* ADJ BARRIER NonJoiner - (nega) - @cc) ;
SETPARENT @cc (NOT p (*)) (-1 ADJ) TO (1* ADJ BARRIER NonJoiner - (nega)) ;

SETPARENT ADJ + $$AGen + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$AGen + $$ANum + $$ADet BARRIER PB OR Pr) ;
SETPARENT ADJ + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$ANum + $$ADet - AGen BARRIER PB OR Pr) ;
MAP @amod ADJ IF (p Noun) ;

####################
# Prepositions
####################

LIST CaseAbleAdv = "כן" "שׁם" "פה" "שׁם" "הלאה" ;
SET CaseAble = Noun - @nummod - @flat OR PRON OR (verb infc) OR (verb infa) OR CaseAbleAdv + ADV OR (prin) OR (inrg);
SET AfterPrep = Det OR @case OR @nummod OR Number + @compound ;
SETPARENT @case (NOT p (*)) TO (1* CaseAble BARRIER NonJoiner - AfterPrep) ;
SETPARENT @case (NOT p (*)) TO (1*A ADJ BARRIER NonJoiner - AfterPrep LINK NOT p (*)) ;

####################
# NP pronoun suffix
####################

MAP @nmod:poss (prn) IF (-1 Noun - (verb)) ;
SETPARENT @nmod:poss (NOT p (*)) TO (-1 Noun) ;
MAP @obj (prn) IF (-1 (verb ptca) OR (verb ptcp)) ;

####################
# Label NP heads
####################

LIST etNotAcc = w3165 ;
ADD PPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead) (c @case - ("את") OR etNotAcc) ;
ADD NPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead OR NPHead) ;

####################
# NP/PP conjunctions
####################

SETPARENT REPEAT @cc (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;
ADD REPEAT HasConj NPHead OR PPHead IF (NOT 0 HasConj) (c @cc) ;

####################
# Apposition
####################

MAP @appos NPHead - HasConj - (nmpr) IF (-1* NPHead OR PPHead BARRIER BD) ;
LIST Titles = "בכר" ;
MAP @appos NPHead - HasConj + (nmpr) IF (-1* NPHead + Titles BARRIER BD OR NPHead OR PPHead) ;

####################
# Connect NPs
####################

SET NonAppos = NPHead - @appos ;

MAP REPEAT @conj PPHead + HasConj IF (-1* PPHead BARRIER BD OR NonAppos) ;
MAP REPEAT @conj PPHead IF (-1* PPHead BARRIER BD OR NonAppos)
                           (1* PPHead + HasConj BARRIER BD OR NonAppos) ;

SECTION
SETPARENT PPHead + @conj (NOT p (*))
    TO (-1* PPHead - @conj BARRIER BD OR NonAppos) ;

SECTION
MAP @conj NPHead + HasConj IF (-1* NonAppos BARRIER BD) ;
MAP @conj NPHead IF (-1* NonAppos BARRIER BD) (1* NPHead + HasConj BARRIER BD) ;
SETPARENT NPHead + @conj (NOT p (*)) TO (-1* NonAppos - @conj BARRIER BD) ;

LIST Family = "בן" "בת" "אב" ;
SETPARENT Family + (subs) (NOT p (*)) TO (-1 (nmpr a)) ;

LIST ApposToLast = w11294 w12566 w12610 w12711 w13874 w14590 w14649 w18761 w18788 ;
SETPARENT CaseAble + ApposToLast (NOT p (*)) TO (-1 (subs) OR (nmpr)) ;
LIST ConjToAppos = w36714 ;
SETPARENT CaseAble + ConjToAppos TO (-1* @appos) ;
SETPARENT CaseAble - ApposToLast - ConjToAppos (NOT p (*))
     TO (-1* BD LINK 1*A CaseAble - @compound:smixut BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @appos CaseAble IF (p CaseAble) ;

SETPARENT PPHead (NOT p (*)) TO (-1* NPHead BARRIER PB) ;
MAP @nmod PPHead IF (p NPHead) ;

####################
# Other labels
####################

MAP @cop (vbcp) IF (0* (PreC) BARRIER CB) ;

SECTION # helper labels

LIST CanAddMaybeClauseRoot = PreC Pred PreO ;
LIST CannotAddMaybeClauseRoot = @cop MaybeClauseRoot @nummod ;
ADD MaybeClauseRoot CanAddMaybeClauseRoot - CannotAddMaybeClauseRoot ;

SECTION # adjacent words

LIST SmallQstQ = inrg prin ;
LIST SmallQstPrn = prde prn ;
MAP @nsubj SmallQstQ IF (-1 BD) (1* SmallQstPrn BARRIER NonJoiner LINK 1 BDsent) ;
SETPARENT SmallQstQ + @nsubj TO (1* SmallQstPrn BARRIER NonJoiner) ;
ADD MaybeClauseRoot SmallQstPrn - MaybeClauseRoot IF (c @nsubj) ;

SECTION # phrase-internal structure

MAP @advmod (subs padv AdvP) IF (-1 BD) (1 BD) ;

ADD (ClauseRoot) (adjv AjCl) - (ClauseRoot) IF (NOT p (*)) ;

MAP @nsubj (prn PreS) ;
MAP @obj (prn PreO) ;
MAP @obj (prn) IF (-1 (verb)) ;
SETPARENT (prn @obj) OR (prn @nsubj) TO (-1 (verb)) ;

SECTION

MAP @obl Noun + (Adju a) ;

SET NonNmCl = (*) - (NmCl) - (prn) ;

MAP @acl (MaybeClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
SETPARENT (subs @acl) TO (-1* (subs) - (NmCl)) ;

SECTION

LIST SubjAble = subs prps nmpr prde ;

MAP @nsubj SubjAble + (Subj) ;

SETPARENT @cop TO (1* (MaybeClauseRoot PreC)) ;
SETPARENT @nsubj TO (1* (MaybeClauseRoot PreC) BARRIER CB) ;

SECTION # conjunction

SETPARENT (conj PP) (NOT p (*)) TO (1* (subs PP)) ;
MAP @conj (subs PP) - (PreC) IF (0 (subs) LINK c @cc) (NOT c @cop) ;
LIST CorC = (@conj) (@compound:smixut) ;
SETPARENT ("בין" subs PP @conj) TO (-1* ("בין" subs PP) - @conj) ;
SETPARENT (subs PP @conj) (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;
MAP @conj (subs NP) IF (0 (subs) LINK c @cc - (CP)) ;
SETPARENT (subs NP @conj) (NOT p (*)) TO (-1* (subs NP) - @conj - @compound:smixut) ;

SECTION

SETPARENT (conj CP) TO (1* MaybeClauseRoot) ;
MAP @acl MaybeClauseRoot IF (c RelMark) ;
SETPARENT @acl TO (-1* CB LINK -1* (subs) BARRIER BD) ;

MAP @advmod (verb infa) IF (1 PB) (2 (verb)) ;
SETPARENT (verb @advmod) (NOT p (*)) TO (2 (verb)) ;

SECTION

LIST ObjAble = subs prn nmpr prin prde ;

ADD (ProbablyObj) ObjAble + (Objc) - (ProbablyObj) ;

SECTION

MAP @xcomp (ProbablyObj) IF (-1* (ProbablyObj) BARRIER (verb MaybeClauseRoot)) ;
MAP @obj (ProbablyObj) IF (NOT -1* (ProbablyObj) BARRIER (verb MaybeClauseRoot)) ;
MAP @ccomp (verb infc Pred) IF (NOT -1* @ccomp) ;
MAP (ClauseRoot @ccomp) (subs MaybeClauseRoot) IF (c (vbcp infc Pred)) (NOT -1* @ccomp) ;
MAP @conj (MaybeClauseRoot Q) IF (-1* (MaybeClauseRoot Q) - @acl BARRIER (N)) ;
MAP @ccomp (MaybeClauseRoot Q) IF (NOT -1* (MaybeClauseRoot Q) - @acl BARRIER (N)) ;
SETPARENT (MaybeClauseRoot Q @conj) (NOT p (*)) TO (-1* (MaybeClauseRoot Q @ccomp)) ;
MAP @root MaybeClauseRoot IF (NOT -1* MaybeClauseRoot) ;

SETPARENT (@ccomp Q) OR ("אמר" verb infc) (NOT p (*)) TO (-1* (quot MaybeClauseRoot)) ;
LIST CcompAble = "חלל" "נתן" "מהר" ;
SETPARENT @ccomp (NOT p (*)) TO (-1* CcompAble + MaybeClauseRoot) ;
LIST SpeakingVerb = quot "ברך" "צוה" ;
SETPARENT ("אמר" infc @ccomp) (NOT p (*)) (c ("ל" prep)) TO (-1* SpeakingVerb) ;

LIST XcompVerb = "ראה" "ירא" "נחם" "שׁחת" "קרא" "מלא" "לבשׁ" "שׁחת" "נגד" "ידע" ;
SETPARENT MaybeClauseRoot + $$Domain (c ("כי" conj @mark)) TO (-1* MaybeClauseRoot + $$Domain BARRIER Domain - $$Domain) ;
MAP @xcomp MaybeClauseRoot IF (c ("כי" conj @mark)) (p XcompVerb) ;
MAP @advcl MaybeClauseRoot IF (c ("כי" conj @mark)) (p (*)) ;

LIST ClauseCon = @conj @parataxis @xcomp ;
LIST NonQuote = N D ? ;
MAP (@conj ClauseRoot) MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) ;

SETPARENT @obj (NOT p (*)) TO (0* (verb MaybeClauseRoot) BARRIER CB) ;
SETPARENT (@obj w107001) TO (-1* (w106997)) ; # why is there a CB in this verse?
SETPARENT @xcomp (NOT p (*)) TO (-1* (verb MaybeClauseRoot)) ;

LIST DontConj = @conj @acl @nmod @xcomp @appos @advcl @nmod:poss ;
SETPARENT MaybeClauseRoot + ClauseCon + $$Domain (NOT p (*)) TO (-1* MaybeClauseRoot + $$Domain - DontConj) ;

LIST OblIsh = Time Cmpl Loca ;
MAP @obl Noun + OblIsh ;

SETPARENT @advmod + VerbInitial TO (-1* (verb MaybeClauseRoot)) ;
SETPARENT @advmod (NOT p (*)) TO (0* (verb MaybeClauseRoot) BARRIER CB) ;
SETPARENT (@advmod AjCl) (NOT p (*)) TO (0* (adjv) BARRIER CB) ;

SETPARENT @discourse TO (1* (ClauseRoot) BARRIER CB) ;

SECTION

MAP @vocative Noun + (Voct) ;
SETPARENT @vocative TO (0* @root) ;

MAP @dislocated Noun + (CPen) ;
SETPARENT (@dislocated Frnt) TO (1* MaybeClauseRoot) ;

SECTION

LIST VerbArgs = @nsubj @obj @obl ;

MAP @obl (subs Adju) ;
MAP @obl (prn PP) IF (c @case - ("את")) ; # TODO: sometimes @nmod ?

SETPARENT VerbArgs (NOT p (*)) TO (0* (MaybeClauseRoot) BARRIER CB) ;

SETPARENT @mark (NOT p (*)) TO (1* (ClauseRoot) OR MaybeClauseRoot) ;

SECTION

SETPARENT @root TO (@0 (*)) ;
SETPARENT Sent TO (-1* @root) ;
LIST PunctToPrev = prep conj (prin @nsubj) @discourse @advmod ;
LIST PunctToNext = @nsubj @advmod @compound:smixut @det @amod @flat @appos ;
LIST PunctToParent = @mark @case @nummod @cc ;
SETPARENT Joiner (NOT p (*)) TO (-1* PunctToPrev BARRIER (*) - BD) ;
SETPARENT Joiner (NOT p (*)) TO (1* PunctToNext BARRIER (*) - BD) ;
SETPARENT Joiner (NOT p (*)) TO (1* PunctToParent BARRIER (*) - BD LINK p (*)) ;
SETPARENT Joiner (NOT p (*)) TO (-1 @obj OR @nummod) ;

SETPARENT @discourse (NOT p (*)) TO (1* (verb) BARRIER (*) - BD) ;
SETPARENT @discourse (NOT p (*))
    TO (1 (prn)) ;
    # TO (1 (prn) LINK p (*)) ; # this one is probably more correct
                                # but we need some other rules first

AFTER-SECTIONS
REMCOHORT (pb) ;
REMCOHORT (cb) ;
REMCOHORT (sb) ;
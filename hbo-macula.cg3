DELIMITERS = "<svb>" ;
OPTIONS += addcohort-attach ;

####################
# Boundaries
####################

LIST PB = pb ;
LIST CB = cb ;
LIST SB = sb ;
LIST SVB = svb ;
LIST BD = pb cb sb svb ;

####################
# POS
####################

LIST Det = art ;
LIST Pr = prep ;
LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;
LIST RelMark = ("אשׁר" conj @mark) ("ה" conj CP Rela) ("שׁ" conj) ;
LIST PRON = prde prps prn ;
LIST ADV = advb nega ;
LIST SCONJ = "כי" "פן" "אשׁר" "אם" "שׁ" "ה" "לולא" "לו" (conj retag:prep) (conj retag:subs ppre) ;

####################
# Subcategories
####################

LIST Participle = ptca ptcp ;

####################
# Text-Fabric labels
####################

# Complete

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;
LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ
LIST AGen = m f ;

####################
# Helper labels
####################

LIST NQ = NQ ;
LIST QuoteLevel = NQ Q QQ ;

####################
# Word lists
####################

LIST Lemma = ".*"r ;

LIST ConjAblePrep = "כמו" "למען" "עד" ;
LIST ConjAbleSubsPrep = "בלת" ;
LIST SubsToPrep = "אחר" "בין" "אצל" "בעד" ;
LIST XcompInf = "יסף" "יכל" "חפץ" "מהר" "אמץ" "חדל" "כלה" "ירא" "מלא" "חלל" "קרב" "יאל" "לאה" "צוה" "נתן" "אבה" ;

LIST Masculine = "מכיר" "אשׁר" "בצע" "בקר" ;
# TODO: BDB says sometimes masculine
LIST FeminineMixed = "ארץ" "יד" "צאן" "אשׁ" "גן" "גפן" ;
# TODO: BDB says sometimes feminine
LIST MasculineMixed = "לחם" "דרך" "אור" "אות" "ארון" "גמל" ;

####################
# Universal Dependencies
####################

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @nsubj:outer = @nsubj:outer ;
LIST @amod = @amod ;       #
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl:relcl = @acl:relcl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       #
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obl:npmod = @obl:npmod ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound = @compound ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @flat = @flat ;
LIST @flat:name = @flat:name ;
LIST @orphan = @orphan ;
LIST @fixed = @fixed ;
LIST @dep = @dep ;       # Any remaining dependency

####################
# Unsorted lists
####################

LIST NPish = NP PP ;
LIST SubsOverride = (Genesis w20500) (Ruth w1233) (Genesis w13703) (Genesis w14216) ; # actually nouns, don't retag as prep
LIST ItgAdv = "מתי" "איפה" "איך" "אן" "מדוע" ;
LIST VoctNonCROverride = (Genesis s81570) (Genesis s81725) (Genesis s85145) (Genesis s82809) (Genesis w9312) ;
LIST ActuallyInf = (Genesis w13111) ;

########################################
# INDIVIDUAL WORDS
########################################

BEFORE-SECTIONS

####################
# Hide Punctuation
####################

MAP REPEAT @punct (punct) ;
REMCOHORT IGNORED REPEAT (punct) ;

####################
# Corrections
####################

LIST MislabeledAsNarrative = w1404 w1405 w1423 w1424 w14251 w14252 w14253 (Genesis s80885) (Ruth s5672) (Ruth s5673) (Genesis s83562) (Ruth s5647) (Ruth s5650) (Ruth s5651) (Genesis s85072) (Genesis s83308) (Genesis s83309) (Genesis s84608) (Genesis s83116) (Genesis s83082) (Genesis s81615) (Genesis s81616) (Genesis s81881) ;
SUBSTITUTE (N) (Q) MislabeledAsNarrative ;

LIST UnknownShouldBeNarrative = (Genesis w2137) ;
SUBSTITUTE (?) (N) UnknownShouldBeNarrative ;

SUBSTITUTE (infc) (infa) (Ruth w797) ;

ADD (m) Noun - AGen IF (0 Masculine OR MasculineMixed) ;
ADD (f) Noun - AGen IF (0 FeminineMixed) ;

SUBSTITUTE (a) (c) (Genesis w3485) ;

####################
# Nested Quotations
####################

LIST DoubleQuoteGen = s80831 s80834 s80836 s80837 s80886 s81424 s81443 s81543 s81737 s81766 s81767 s81785 s81829 s81933 s81999 s82001 s82028 s82037 s82159 s82295 s82315 s82367 s82380 s82382 s82410 s82412 s82413 s82446 s82450 s82599 s82626 s82629 s82776 s82946 s83252 s83255 s83285 s83303 s83318 s83319 s83327 s83431 s83432 s83449 s83459 s83470 s83474 s83479 s83480 s83482 s83510 s83626 s83628 s83906 s83919 s84071 s84283 s84313 s84382 s84435 s84464 s84492 s84537 s84545 s84551 s84552 s84555 s84638 s84673 s84681 s84708 s84709 s84719 s84722 s84765 s84804 s84805 s84828 s84934 s84941 s84943 s85134 s85229 s85230 s85261 s85262
c29820 ; # TODO: handle rela:Objc properly
LIST DoubleQuoteRuth = s5648 s5649 s5720 s5825 ;
SET DoubleQuote = (Genesis) + DoubleQuoteGen OR (Ruth) + DoubleQuoteRuth ;
SUBSTITUTE (Q) (QQ) DoubleQuote ;

ADD NQ (*) - QuoteLevel ;

####################
# MWE names
####################

SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בית" wp1) ;
SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בן" wp1) ;
SUBSTITUTE (nmpr) (subs retag:nmpr m) ("אל" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("לחם" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("צדק" wp2) ;
SUBSTITUTE ("מלכי" nmpr) ("מלך" subs c retag:nmpr) (wp1 Genesis w6557) ;
SUBSTITUTE ("עמי" nmpr) ("עם" subs retag:nmpr has_prn) ("עמי" wp2) ;
SUBSTITUTE ("אוני" nmpr) ("און" subs retag:nmpr has_prn) ("אוני" wp2) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("עם" subs retag:nmpr) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("און" subs retag:nmpr) ;
MAP @nmod:poss (prn) IF (p (wp2)) ;

MAP @flat:name (nmpr wp2) IF (-1 (nmpr wp1)) ;
SETPARENT @flat:name TO (-1* (nmpr wp1)) ;

SETPARENT (wp2) TO (-1* (wp1)) ;
SETPARENT (*) - (prn) TO (p (wp2) LINK p (wp1)) ;
MAP @compound:smixut (wp2) IF (p (wp1 c)) ;

####################
# MWE conjunctions
####################

WITH ("אם" conj) OR ("כי" conj) IF (-1 ("עד" prep)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP @fixed (*) ;
  SUBSTITUTE (prep) (conj retag:prep ExtPos=SCONJ) _C1_ ;
} ;

WITH ("בלת" subs) - @fixed IF (-1 ("ל" prep)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP @fixed (*) ;
  ADD (ExtPos=SCONJ) _C1_ ;
} ;

####################
# Retagging
####################

# quotation
MERGECOHORTS ("<le'emor>" "$2$1"v SCONJ *) ("(אמר)"r verb infc) - ActuallyInf WITH (-1 ("(ל)"r prep)) ;

# Substantivized adjectives
SUBSTITUTE (adjv) (subs retag:adjv) (c) ;
SUBSTITUTE (adjv) (subs retag:adjv) (a) (1 BD) (-1* Noun + (c) BARRIER (*) - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv a) (1 (prn)) ;
# TODO: does this really apply to all gentillics?
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl pl) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (-1* Noun + (c) BARRIER (*) - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (NEGATE 0* (subs) - (retag:adjv gntl) OR (nmpr) BARRIER PB) ;

# Participles in smixut
SUBSTITUTE (verb) (subs retag:verb) Participle + NPish - (NpAdjp) IF (NEGATE c (role:O));
SUBSTITUTE (verb) (subs retag:verb) Participle + (c) IF (c (NPofNP)) ;

# Adverbs tagged subs
SET AdvOk = (*) - (prn ModS) - ("מאד" padv) ;
SUBSTITUTE (subs) (advb retag:subs) (padv) - (NP) (-1* BD BARRIER AdvOk) (1* BD BARRIER AdvOk) ;
LIST AdvRules = AdvpNp AdvpNump AdjpAdvp ;
SUBSTITUTE (subs) (advb retag:subs) (padv) + AdvRules ;

# Determiner on clause participles
SUBSTITUTE (art) (conj retag:art) (CP Rela) ;

# Prepositions tagged as nouns
SUBSTITUTE (subs) (conj retag:subs) ConjAbleSubsPrep + (CP) ;
SUBSTITUTE (subs) (advb retag:subs) ("אחר" subs ppre AdvP) (1 BD) ;
SUBSTITUTE (subs) (prep retag:subs) SubsToPrep + (subs ppre) ;
SUBSTITUTE (subs) (prep retag:subs) (ppre CP Conj)
    IF (NOT 0 SubsOverride)
       (NEGATE 0 ("טרם" subs) LINK -1 ("ב" prep))
       (NEGATE 0 ("בלי" subs CP) LINK -1* ("על" prep) BARRIER PB) ;

SUBSTITUTE (prep) (conj retag:prep) ConjAblePrep + (CP)
    IF (NOT 1 ("אשׁר" conj)) ;

# yesh and ein
SUBSTITUTE (subs) (verb retag:subs ClauseRoot) (nmcp) ;

# interrogative adverbs
SUBSTITUTE (inrg) (advb retag:inrg) ItgAdv ;

####################
# Lookup table overrides
####################

LIST ChildOverrides = (Genesis w45) ;
LIST ParentOverrides = (Genesis w41) ;

SETPARENT ChildOverrides TO (0* ParentOverrides) ;

LIST ObjOverrides = (Genesis w45) ;

MAP @obj ObjOverrides ;

WITH ("נגד" subs role:PP) IF (-1 ("כ" prep) LINK -1 ("עזר" subs)) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP @nmod (*) ;
} ;

####################
# Consistent labels
####################

MAP @det Det ;
MAP @mark SCONJ + (conj CP) OR (ExtPos=SCONJ) ;
MAP @mark ("ה" inrg) ;
MAP @obj ("את") + Pr IF (1 RelMark) ;
MAP @obl Pr IF (1 RelMark) ;
MAP @case Pr - (ExtPos=SCONJ) ;
MAP @cc (conj) - (Rela) ;
MAP @advmod ADV - (role:P) - (ClCl2) ;
MAP @advmod ("למה" inrg) ;
MAP @discourse (intj) - (role:P) OR (intj uprole:S) ; # TODO: is there a better way to handle הנה?

####################
# Pronoun suffixes
####################

SUBSTITUTE ("prn") ("אני") ("prn" prn p1 sg) ;
SUBSTITUTE ("prn") ("אנחנו") ("prn" prn p1 pl) ;
SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("את") ("prn" prn p2 f sg) ;
SUBSTITUTE ("prn") ("אתם") ("prn" prn p2 m pl) ;
SUBSTITUTE ("prn") ("אתן") ("prn" prn p2 f pl) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("היא") ("prn" prn p3 f sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;
SUBSTITUTE ("prn") ("הן") ("prn" prn p3 f pl) ;

####################
# Role overrides
####################

LIST CCONJ = ("ו" conj) ("או" conj) ;
SETPARENT CCONJ - (_) (pl (*)) TO (sllr (*)) ;

LIST FinCL = /((S|V|O2?|PP?|ADV)-)+(S|V|O2?|PP?|ADV)/r ;
LIST FinCLPP = /((S|V|O2?|PP?|ADV)-)+PP/r ;
LIST EllpCL = /^((S|O2?|PP|ADV)-)+(S|O2?|PP|ADV)$/r ;
LIST VerbCL = /^V-|-V-|-V$/r ;

LIST ConjSeq = /Conj\\d.*/r ;

MAP @conj ConjSeq IF (c (conj)) ;

MAP @conj $$Function IF (c ("ו" conj)) (p $$Function) ;

MAP @compound:smixut (NP) IF (p (subs ptcp c)) ;

# TODO: genesis 261 has smixut
LIST ReflexiveNouns = "אח" "רע" ;
WITH ("אישׁ" subs role:ADV)
  IF ((c ReflexiveNouns + (subs NpPp))
      OR (sw (c role:O) LINK c ReflexiveNouns)) {
  MAP @parataxis (*) ;
  SETCHILD (*) TO (jC1 (*)) ;
  MAP @orphan _C1_ ;
} ;

MAP @orphan EllpCL ;

####################
# By role
####################

WITH NOMAPPED (role:ADV) {
  MAP @xcomp (PrAd) OR (Subj) ;
  MAP @obj (Objc) IF (NEGATE s (role:O)) ;
  MAP @obl (NP rela:Attr) OR (NP Time) OR (adjv ordn) OR (NP Modi) ;
  MAP @obl (NP) + VerbCL IF (NEGATE s (role:O)) ;
  MAP @xcomp (NP) + VerbCL ;
  MAP @obl:npmod (infa) + $$Lemma IF (p $$Lemma) (NEGATE c (CLaCL)) ;
  MAP @advcl (infa) OR (infc) ;
  MAP @obl (subs) OR (nmpr) ;
  MAP @xcomp (adjv) ;
  MAP @advcl (verb perf) IF (c (relCL @mark)) ;
  MAP @advmod (*) - (nmcp) ;
} ;

WITH NOMAPPED (role:Appos) {
  MAP @dislocated (*) IF (pl (role:S) LINK pr (*) LINK 1* _TARGET_) ;
  MAP @amod (adjv) ;
  MAP @acl:relcl (verb ptca) ;
  MAP @compound:smixut (*) IF (-1* (c) BARRIER (*) - Det LINK c _TARGET_) ;
  MAP @appos (*) ;
} ;

WITH NOMAPPED (role:O) - (Ellp CLaCL) {
  MAP @xcomp (verb infc) IF (p XcompInf) ;
  MAP @ccomp (verb) - Participle ;
  MAP @obj (*) IF (NEGATE c (vbcp) - (NpRelp)) ;
} ;

MAP @xcomp (role:O2) ;

WITH NOMAPPED (role:PP) {
  MAP @mark (SCONJ) ;
  MAP @xcomp (verb infc) IF (p XcompInf) (c ("ל" prep) OR ("מן" prep)) ;
  MAP @advcl (verb infc) IF (c ("ל" prep) OR ("מן" prep)) ;
  MAP @nmod (*) IF (p (subs retag:verb)) ;
  MAP @xcomp (PrAd) IF (NEGATE s (role:O2)) ;
  MAP @obl (*) IF (NEGATE c (vbcp) - (NpRelp) OR (relCL @mark)) ;
} ;

WITH NOMAPPED (role:S) - (_) {
  MAP @nsubj:outer (S-P) OR (ADV-S-P) IF (p (role:V)) ;
  MAP @csubj (*) IF (c (relCL @mark)) ;
  MAP @nsubj (*) ;
} ;

LIST roleVP = role:V role:P ;
WITH NOMAPPED roleVP {
  MAP @xcomp (*) IF (p (nmcp role:ADV)) ;
  MAP @xcomp (infc uprole:O) OR (uprole:O2) ;
  MAP @advcl (infc uprole:ADV) OR (infa uprole:ADV) ;
  MAP @ccomp (uprole:O) IF (NEGATE c (relCL @mark)) ;
  MAP @conj (CLaCL) ;
  #MAP @cop (vbcp) + FinCL ;
  # TODO: perf error in genesis 427?
  MAP @acl:relcl (verb ptca Np-Appos) OR (verb perf Np-Appos) ;
  MAP @parataxis (NpCL) - (ptca) - (ptcp) - (nmcp) - (rela:Attr) IF (NEGATE c @mark) ;
  MAP @obl (uvf:H AdvP uprole:ADV) OR (Cmpl V-ADV uprole:ADV) ;
  MAP @csubj (verb ptca uprole:S) ;
  MAP @xcomp (verb ptca uprole:ADV) ;
  MAP @nsubj (PrNP uprole:S) ;
} ;

####################
# Static labels
####################

LIST AclRules = NpRelp PpRelp NpCL AdvpRelp OmpRelp
                (verb infc NpInf) ; # TODO: maybe actually plain @acl?
LIST ApposRules = (2Advp_h2 subs) ;
LIST FlatRules = NumpNump ;
LIST NmodRules = NpPp NumpPp AdvpPp2 ;
LIST NummodRules = NpNump NumpNP ;

MAP (@acl) (infc NpPp) ;
MAP @acl:relcl AclRules ;
MAP @appos ApposRules ;
MAP @flat FlatRules ;
MAP @nmod NmodRules ;
MAP @nummod NummodRules ;

MAP @det (prde NumpAdjp) ;
MAP @mark (SCONJ) ;
MAP @nmod:poss (prn PrepNp+NomPrep) OR (prn QuanNP) ;
MAP @obl (prin AdvpAdjp) ;
MAP @parataxis (ClClCl) OR (ClClClCl) ;

####################
# Simple labels
####################

WITH NOMAPPED (2Pp) {
  MAP @appos (*) IF (c @case + $$Lemma) (s @case + $$Lemma) ;
  MAP @nmod (*) ;
} ;

WITH NOMAPPED (AdjpNp) {
  MAP @det (prde) ;
  MAP @amod (*) ;
} ;

WITH NOMAPPED (AdjpPp) {
  MAP @obl (*) IF (p (verb)) ;
  MAP @obl (*) IF (p @conj LINK p (verb)) ;
  MAP @nmod (*) ;
} ;

WITH NOMAPPED (ClCl) {
  MAP @advcl (verb infc) IF (p (verb) - (infc)) ;
  MAP @vocative (Voct) IF (p (_) OR roleVP OR (intj ClCl2)) ;
  MAP @xcomp (*) IF (p ("ראה")) (c ("כי")) ;
  MAP @acl:relcl (*) IF (c (relCL @mark)) (p (NP) OR (PrNP)) ;
  MAP @acl:relcl (*) IF (c (relCL @mark) LINK sl (prep)) ;
  MAP @advcl (*) IF (c (conj) - ("ו")) ;
  MAP @xcomp (ptca) IF (NEGATE c @nsubj) ;
  MAP @parataxis (*) ;
} ;

LIST NorP = NP PP PrNP PPrP ;
LIST dislocatedClCl2 = (CPen Frnt) Subj Adju PreC ;
WITH NOMAPPED (ClCl2) {
  MAP @obl (PP Time) ;
  MAP @vocative (Voct) IF (p (_) OR (role:P) OR (role:V)) ;
  MAP @vocative (<txt:0>) IF (p (<txt:1>)) ;
  MAP @dislocated dislocatedClCl2 + NorP OR dislocatedClCl2 + (prde);
  MAP @obl (Modi) + NorP ;
  MAP @xcomp (role:V) IF (c (relCL @mark)) ;
  MAP @advcl (nmcp) OR (role:V uprole:V) ;
  MAP @advcl (*) IF (c (conj) - ("ו")) ;
} ;

WITH NOMAPPED (NP3NP) {
  MAP @conj (*) IF (sr (*) LINK c @cc) ;
  MAP @appos (*) ;
} ;

WITH NOMAPPED (NpAdjp) {
  MAP @det (prde) OR (ppde) ;
  MAP @acl:relcl (verb) ;
  MAP @nummod (adjv ordn) ;
  MAP @nmod (subs retag:adjv) IF (NOT p (c)) ;
  MAP @compound:smixut (subs retag:adjv) ;
  MAP @amod (*) ;
} ;

WITH NOMAPPED (NpNpNp) {
  MAP @conj (*) IF (p (_)) ;
  MAP @appos (*) ;
} ;

WITH NOMAPPED (NPofNP) {
  MAP @appos (prde) ;
  MAP @obj (prn) IF (-1 (verb ptca)) ;
  MAP @nmod:poss (prn) ;
  MAP @acl:relcl (verb ptca) ;
  MAP @obj (*) IF (p (verb ptca @acl:relcl)) ;
  MAP @compound:smixut (*) IF (p (c) OR (subs a dir_he)) ;
  MAP @nmod (adjv) ;
  MAP @obj (*) IF (p (verb ptca a)) ;
  MAP @appos (*) ;
} ;

WITH NOMAPPED (ppCL) {
  MAP @advcl (*) IF (p (ExtPos=SCONJ)) ;
  SETPARENT @advcl TO (p (ExtPos=SCONJ) LINK p (*)) ;
  SETCHILD @advcl TO (s (ExtPos=SCONJ)) ;
  MAP @acl:relcl (*) ;
} ;

MAP @acl:relcl (verb ptca a) IF (p (c)) ;

LIST CompoundAble = QuanNP PrepNp+NomPrep AdjpofNp ;
MAP @compound:smixut CompoundAble IF (p (c)) ;

LIST ListRules = 2PpaPp AdjpAdjpandAdjp AdjpandAdjpAdjp CLaCL
	 		     2CLaCL 2Np 2NpaNpaNp 2Pp 3NpaNp AdjpaAdjp aNpaNp aNpaNpaNp
				 CLaCL CLandCL2 Conj3CL Conj4Np Conj4Pp Conj5Np
				 NP3NP NpaNp NPaNPaNPNPaNP NPaNPNP NPaNPNPaNP NpNpNp
				 NPNPNPaNPaNP NpNpNpNp NpPp NumpAndNump
				 PPandPP PpaPpPpaPp Relp3Relp PpPp PpandPpPp ;
MAP @conj ListRules ;

MAP @csubj FinCL + (rela:Subj) ;

WITH (verb infc) + FinCLPP IF (c (prep PrepCL)) {
  MAP @xcomp (*) IF (p XcompInf) ;
  MAP @advcl (*) ;
} ;

####################
# Other rules
####################

# end of BEFORE-SECTIONS
SECTION

SETPARENT @acl:relcl + roleVP TO (p (QuanNP @compound:smixut) LINK p (*)) ;
SETPARENT @dislocated + (role:Appos) TO (p @nsubj LINK p (*)) ;

SETPARENT @vocative TO (p @discourse LINK p (*)) ;

LIST AdvConj = CLaCL aNpaNp ;
SETPARENT @advmod + $$AdvConj (pl (*)) TO (sr $$AdvConj) ;

SETPARENT @obj (p (nmcp role:ADV)) TO (sl (role:V @xcomp)) ;

WITH (PpPp @conj) IF (pr @obl) {
  SETPARENT (*) TO (p (*) LINK p (*)) ;
  SUBSTITUTE @conj @obl (*) ;
} ;

SETPARENT (@case PpPp) TO (p @case LINK p (*)) ;

WITH @obl + Pr IF (p (*)) (s (relCL @mark)) {
  SETCHILD (*) TO (sl @cc) ;
  SETPARENT (*) TO (jC1 (*) LINK p (*)) ;
  SETCHILD (*) TO (jC1 (*)) ;
  MAP @acl:relcl _C1_ ;
  SUBSTITUTE @conj @acl:relcl _C1_ ;
  SUBSTITUTE @obl @conj (*) IF (jC1 (Conj4Pp)) ;
} ;

# fixes genesis 896 - fragile, may break other things
WITH NOPARENT (subs) - (_) IF (-1 (subs c) - (ppre) - @nummod OR (nmpr c)) {
  SETPARENT SAFE (*) TO (jC1 (*)) ;
  MAP @compound:smixut (*) ;
} ;

SETPARENT SAFE @det TO (1 (subs)) ;
SETPARENT SAFE (subs) TO (-1* (subs c) BARRIER (*) - Det) ;
WITH NOPARENT (subs) IF (-1 @det) (-2 (subs c) - (ppre) - @nummod) {
  SETCHILD (*) TO (jC1 (*)) ;
  SETPARENT (*) TO (jC2 (*)) ;
  MAP @compound:smixut (*) ;
} ;

WITH NOMAPPED (subs PrepNp) IF (p (*)) {
  SETPARENT (*) TO (p (*) LINK p (*)) ;
  MAP @obl (*) ;
  SETCHILD (*) TO (jC1 (*)) ;
  SUBSTITUTE @obl @nmod:poss _C1_ IF (0 (prn)) ;
  SUBSTITUTE @obl @compound:smixut _C1_ ;
} ;

SETPARENT SAFE Det TO (1 (prde)) ;

SECTION

SETPARENT (*) TO (p ("ו" conj) LINK p (*)) ;

WITH (subs ppre c) - @acl:relcl IF (p @obl) {
  MAP @obl (*) ;
  SUBSTITUTE @obl @compound:smixut (*) IF (jC1A (*)) ;
  SETPARENT (*) TO (jC1 (*) LINK p (*)) ;
  SETCHILD (*) TO (jC1 (*)) ;
} ;

SETPARENT @appos OR @nmod TO (p (QuanNP) LINK p (*)) ;

SETPARENT SAFE (SCONJ) TO (1* @ccomp) ;

SETPARENT @nsubj TO (p @discourse LINK p (*)) ;

WITH (nmpr) IF (-1 (subs c)) (NOT p (*)) {
	SETPARENT (*) TO (-1 (*)) ;
	MAP @compound:smixut (*) ;
} ;

WITH (PpPpPpPp) OR (PpPpPp) IF (p @obl) {
  SETPARENT (*) TO (p (*) LINK p (*)) ;
  MAP @obl (*) ;
} ;

MAP @advcl (infc uprole:PP) IF (c @case) ;
MAP @obl (uprole:PP) IF (c @case) ;

LIST CcAdvList = PPandPP NpaNp ;
WITH @cc + (CjpCjp) IF (p @advmod + CcAdvList) {
  SETPARENT (*) TO (p (*) LINK sr (*)) ;
  SETPARENT _C1_ TO (srll (*)) ;
} ;

####################
# Clause Connections
####################

SECTION

LIST TextLevel = <txt:0> <txt:1> <txt:2> ;

SET NonPredAdv = (advb) - (role:P) ;
SET Top = (_) - (conj) - @discourse - NonPredAdv ;

SETPARENT (conj _) (p (>>>)) TO (1* (_)) ;

LIST NonAdvclConj = "ו" retag:art "או" ;

WITH (PP Adju _) + $$TextLevel IF (1* (_ role:V) + $$TextLevel) {
  SETPARENT (*) TO (jC1 (*)) ;
  MAP @obl (*) ;
} ;

WITH Top + (/^<txt:\(\\d+\)>$/r) - @advcl - (_override)
  IF (-1* Top + (VSTR:<txt=$1>) BARRIER Top) (c (conj) - NonAdvclConj) {
    SETPARENT (*) TO (jC1 (*)) ;
    MAP @conj (*) IF (c @cc) (jC2 $$Lemma) (s (conj) + $$Lemma) ;
	  MAP @advcl (*) ;
} ;

WITH Top + (/^<txt:\(\\d+\)>$/r) - @advcl - (_override) - (SCONJ)
  IF (-1*O (>>>) OR Top + (VSTR:<txt<$1>) LINK 1* Top + (VSTR:<txt=$1>) LINK ppSrr Top + (VSTR:<txt=$1>)) (NEGATE c ("או" conj)) {
    SETPARENT (*) TO (jC1 (*)) ;
    MAP @advcl (*) IF (c @mark - (retag:art) - (inrg)) ;
    MAP @conj (*) IF (c (conj) - (retag:art)) ;
	SETPARENT (verb infc) (c (prep)) TO (p (*) LINK c (@xcomp verb infc)) ;
} ;

LIST SpeakingVerb = quot "ברך" "צוה" "נגד" "דבר" "ענה" "שׁמע" "מלל" ;

WITH Top + (/^<txt:\(\\d+\)>$/r)
  IF (llccS Top LINK -1* Top + (VSTR:<txt<$1>) - (SCONJ) BARRIER Top - (SCONJ))
     (NEGATE pr (*)) {
    SETPARENT (*) TO (jC1 (*)) ;
    MAP @ccomp (*) IF (jC1 SpeakingVerb) ;
} ;

MAP @ccomp (/^<txt:\(\\d+\)>$/r) + FinCL IF (p SpeakingVerb + (VSTR:<txt<$1>)) ;

SUBSTITUTE @advmod @ccomp (/^<txt:\(\\d+\)>$/r) + Top
  IF (p SpeakingVerb + (VSTR:<txt<$1>)) ;

WITH Top + NPish + (CPen Frnt) + $$TextLevel
  IF (1* Top + $$TextLevel) {
    SETPARENT (*) TO (jC1 (*)) ;
    MAP @dislocated (*) ;
} ;

SETPARENT SAFE (SCONJ /^<txt:\(\\d+\)>$/r) TO (1* (_ VSTR:<txt>$1>)) ;
SETPARENT (SCONJ /^<txt:\(\\d+\)>$/r) (p (<<<)) TO (1* (_ VSTR:<txt>$1>)) ;
MAP @advcl (*) IF (c (SCONJ)) ;

SETPARENT @advmod + (_) TO (p @advmod + (_) LINK p (*)) ;
SETPARENT @advmod + (_) OR @cc + (_) OR @cc + (CjpCjp) (pr (_) LINK sl (_) LINK -1* _TARGET_)
  TO (1* Top - @advmod - @cc) ;

SETPARENT (advb _) (p (>>>)) TO (sllr (*)) ;
LIST AdvChild2Sibling = (@cc CjpCjp) (@mark CjpCjp) (@advmod CjpAdvp2Advp) ;
SETPARENT AdvChild2Sibling TO (pr @advmod LINK pr (*)) ;

SECTION

SETPARENT (_ @advmod) (p (>>>)) TO (1* (_)) ;
SETPARENT (_) (p (>>>)) TO (slll (*)) ;

WITH (ptca @acl:relcl) IF (p @case) (NEGATE c @mark) {
  SETPARENT (*) TO (p (*) LINK p (*)) ;
  SUBSTITUTE @acl:relcl @advcl (*) ;
  SETCHILD (*) TO (jC1 (*)) ;
} ;

SECTION

MAP @ccomp (rela:Objc) ;

SETPARENT (_ <txt:1>) (p (<txt:0>)) TO (slll (_ <txt:1>) - (conj)) ;

LIST NPConj = NpaNp 2Np 2NpaNpaNp NP3NP NpaNp NPaNPaNPNPaNP NPaNPNP
              NPaNPNPaNP NpNpNp NpNp (NP _) ;
LIST PPConj = PpaPp Conj3Pp PPandPP 2PpaPp PPandPP PpaPpPpaPp PpandPpPp ;
LIST ClauseConj = CLaCL 2CLaCL (VP _) ;
SET ConjTypes = NPConj OR PPConj OR ClauseConj ;
SETPARENT @conj + &&ConjTypes (NEGATE sr @acl:relcl) (NEGATE c ("או" conj))
  TO (p @conj + &&ConjTypes LINK p (*)) ;

SETPARENT (intj @discourse) TO (p (intj @discourse) LINK p (*)) ;

WITH @acl:relcl IF (p ("למען" conj @mark)) {
  SUBSTITUTE @acl:relcl @advcl (*) ;
  SETPARENT (*) TO (jC1 (*) LINK p (*)) ;
  SETCHILD (*) TO (jC1 (*)) ;
} ;

SECTION

LIST PredFunction = Cmpl PreC ;
SET CopPredicate =
      (@obj)
   OR (role:O)
   OR (role:PP @obl) + PredFunction - (/-O-|^O-|-O$/r Time)
   OR (PreC V-O)
   OR (role:ADV infa) ;

WITH CopPredicate IF (p (vbcp) - @cop)
  (NEGATE 0 (Cmpl) LINK s (PreC))
{
  UNMAP (*) ;
  ADD (_) (*) IF (jC1 (_)) ;
  MAP (VSTR:$1) (*) (jC1 (/^\(@.*\)$/r)) ;
  UNMAP _C1_ ;
  MAP @cop _C1_ ;
  SETCHILD REPEAT (*) TO (s (*)) ;
  SETPARENT (*) TO (jC1 (*) LINK p (*)) ;
  SETCHILD (*) TO (jC1 (*)) ;
} ;

# Don't call it apposition if it's on the other side of the verb
WITH (@appos) IF (pl @nsubj LINK prw (*) LINK ccr _TARGET_) {
  SETPARENT (*) TO (jC1 (*)) ;
  SUBSTITUTE @appos @dislocated (*) ;
} ;

SUBSTITUTE @obj OR @obl @conj (prep) IF (p (prep)) ;

# guideline examples all have comparatives with @obl
SUBSTITUTE @nmod @obl (AdjpPp) IF (s @cop) (c ("מן" prep @case)) ;

# for some reason this breaks @det rules if run in the MWE section
# e.g. genesis 766 - probably a bug that should be investigated
# (git blame for commit immediately after adding this rule)
WITH ("כי" conj CjpCjp) IF (p ("אם" conj)) {
  SETPARENT (*) TO (p (*) LINK p (*)) ;
  SETCHILD (*) TO (jC1 (*)) ;
  SUBSTITUTE (conj) (conj ExtPos=SCONJ) (*) ;
  SUBSTITUTE @mark @fixed _C1_ ;
} ;

SETPARENT @acl:relcl TO (p @compound:smixut LINK p ("כל")) ;

SETPARENT (*) - @fixed TO (p @mark LINK p (*)) ;

AFTER-SECTIONS

MAP @dep (*) - (_) ;

MAP @root (*) ;

WITH @root IF (p (*) LINK p (*)) {
  SUBSTITUTE @root @conj (*) IF (c @cc) ;
  SUBSTITUTE @root @conj (*) IF (sr (*) LINK c @cc) ;
  SUBSTITUTE @root @parataxis (*) ;
} ;

REMCOHORT (pb) ;
REMCOHORT (cb) ;
REMCOHORT (sb) ;
REMCOHORT (svb) ;
#REMCOHORT (excb) ;

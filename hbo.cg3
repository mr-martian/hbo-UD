DELIMITERS = "<׃>" ;

LIST PB = pb ;
LIST CB = cb ;
LIST BD = pb cb ;

LIST Det = art ;

LIST Pr = prep ;

LIST Sent = sent ;
LIST Cm = cm ;

LIST MaybeClauseRoot = MaybeClauseRoot ;

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;

LIST VerbInitial = Way0 WayX ;

LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;

LIST Joiner = ("׀" punct) ("־" punct) ;

LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ

# Universal Dependencies
# ======================

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @iobj = @iobj ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @dep = @dep ;       # Any remaining dependency

SECTION # context-free mappings

MAP @punct (punct) ;
MAP @det Det ;
MAP @case Pr ;
MAP @nummod (card) OR (ordn) ;
MAP @compound:smixut Noun IF (-1* Noun + (c) - @nummod BARRIER (*) - Det - Joiner) ;
MAP @mark ("כי" conj CP) ;
MAP @cc (conj) - (Rela) ;
MAP @cop (vbcp) IF (0* (PreC) BARRIER CB) ;
MAP @advmod (nega) ;
MAP @advmod (advb) ;
MAP @discourse (intj) ; # TODO: is there a better way to handle הנה?

SECTION # helper labels

LIST CanAddMaybeClauseRoot = PreC Pred ;
LIST CannotAddMaybeClauseRoot = @cop MaybeClauseRoot @nummod ;
ADD MaybeClauseRoot CanAddMaybeClauseRoot - CannotAddMaybeClauseRoot ;

SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;

SECTION # name lists

MAP @conj (nmpr PrNP) IF (-1 @cc) (-2 (nmpr PrNP)) ;
MAP @conj (nmpr PrNP) IF (-1 (nmpr PrNP)) (1* @cc BARRIER (*) - (nmpr PrNP) LINK 1 (nmpr PrNP)) ;
SETPARENT (nmpr PrNP @conj) (NOT p (*)) TO (-1* (nmpr PrNP) - @conj) ;

SECTION # adjacent words

LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;

SETPARENT @compound:smixut TO (-1* Noun) ;

SETPARENT (art @det) TO (1 (subs) OR (adjv) or (prde)) ;
MAP @det (prde) + $$AGen + $$ANum IF (-1 (art)) (-2 (subs det) + $$AGen + $$ANum) ;
MAP @det (prde pl) IF (-1 (art)) (-2 (subs det pl)) ;
SETPARENT (prde @det) TO (-2 (subs)) ;

SECTION # phrase-internal structure

MAP @amod (adjv) ; # TODO: adj as MaybeClauseRoot, or is that covered by PreC?
LIST AdjAble = subs nmpr ;
SETPARENT @amod + $$AGen + $$ANum + $$ADet
    TO (-1* AdjAble + $$AGen + $$ANum + $$ADet) ;

SETPARENT @nummod TO (0* Noun - @nummod BARRIER (*) - @nummod) ;

LIST YesCaseAble = subs (verb infc) prn nmpr prps prde ;
SET CaseAble = YesCaseAble - @nummod ;
SETPARENT @case TO (1* CaseAble BARRIER BD) ;

MAP @obj (prn) IF (-1 (verb)) ;
SETPARENT (prn @obj) TO (-1 (verb)) ;

# TODO: this should probably be stricter
MAP @iobj (prn PP Cmpl) IF (0 (*) LINK c ("ל" prep)) ;
SETPARENT (prn @iobj) TO (0* (verb) BARRIER CB) ;

MAP @nmod:poss (prn) IF (-1 (subs)) ;
SETPARENT (prn @nmod:poss) TO (-1 (subs)) ;

SETPARENT @cc TO (1* CaseAble BARRIER BD) ;

LIST ApposToLast = w11294 w14590 w18761 ;
SETPARENT CaseAble + ApposToLast TO (-1 (subs)) ;
LIST ConjToAppos = w36714 ;
SETPARENT CaseAble + ConjToAppos TO (-1* @appos) ;
SETPARENT CaseAble - ApposToLast - ConjToAppos (NOT p (*))
     TO (-1* BD LINK 1*A CaseAble - @compound:smixut BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @nmod CaseAble + (ppre) IF (p CaseAble) ;
MAP @appos CaseAble IF (p CaseAble) ;

MAP @conj (subs) IF (c @cc) (-1* CaseAble BARRIER BD LINK NOT p (*)) ;
MAP @nmod (subs) IF (c @case - ("את")) (-1* CaseAble BARRIER BD LINK NOT p (*)) ;
MAP @appos (subs) IF (NOT c @case) (NOT c @cc) (-1* CaseAble BARRIER BD LINK NOT p (*)) ;
LIST NounNoun = @nmod @conj @appos ;
SETPARENT (subs) + NounNoun (NOT p (*)) TO (-1* CaseAble BARRIER BD LINK NOT p (*)) ;

SECTION

MAP @obl Noun + (Adju a) ;

SET NonNmCl = (*) - (NmCl) - (prn) ;
LIST RelMark = ("אשׁר" conj) ;

MAP @acl (MaybeClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
MAP @mark RelMark ;
SETPARENT (subs @acl) TO (-1* (subs) - (NmCl)) ;
SETPARENT RelMark + (NmCl) TO (1* @acl BARRIER NonNmCl) ;

SECTION

LIST SubjAble = subs prps nmpr prde ;

MAP @nsubj SubjAble + (Subj) ;
SETPARENT @nsubj TO (-1* (verb Pred) BARRIER (*) - Joiner - ("<prn>") - ("את" prep));

SETPARENT @cop TO (1* (MaybeClauseRoot PreC)) ;
SETPARENT @nsubj TO (1* (MaybeClauseRoot PreC) BARRIER CB) ;

SECTION # conjunction

SETPARENT (conj PP) TO (1* (subs PP)) ;
MAP @conj (subs PP) - (PreC) IF (0 (subs) LINK c @cc) (NOT c @cop) ;
LIST CorC = (@conj) (@compound:smixut) ;
SETPARENT ("בין" subs PP @conj) TO (-1* ("בין" subs PP) - @conj) ;
SETPARENT (subs PP @conj) (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;
MAP @conj (subs NP) IF (0 (subs) LINK c @cc - (CP)) ;
SETPARENT (subs NP @conj) (NOT p (*)) TO (-1* (subs NP) - @conj - @compound:smixut) ;

SECTION

SETPARENT (conj CP) TO (1* MaybeClauseRoot) ;

SECTION

LIST Domain = N D Q ? ;

LIST ObjAble = subs prn nmpr ;

ADD (ProbablyObj) ObjAble + (Objc) - (ProbablyObj) ;

SECTION

MAP @xcomp (ProbablyObj) IF (-1* (ProbablyObj) BARRIER (verb MaybeClauseRoot)) ;
MAP @obj (ProbablyObj) IF (NOT -1* (ProbablyObj) BARRIER (verb MaybeClauseRoot)) ;
MAP @ccomp (verb infc Pred) IF (NOT -1* @ccomp) ;
MAP @conj (MaybeClauseRoot Q) IF (-1* (MaybeClauseRoot Q) BARRIER (N)) ;
MAP @ccomp (MaybeClauseRoot Q) IF (NOT -1* (MaybeClauseRoot Q) BARRIER (N)) ;
SETPARENT (MaybeClauseRoot Q @conj) TO (-1* (MaybeClauseRoot Q @ccomp)) ;
MAP @root MaybeClauseRoot IF (NOT -1* MaybeClauseRoot) ;
SETPARENT @obj OR @xcomp TO (-1* (verb MaybeClauseRoot)) ;

SETPARENT (@ccomp Q) OR ("אמר" verb infc) TO (-1* (quot MaybeClauseRoot)) ;
#SETPARENT @ccomp TO (-1* ("אמר" MaybeClauseRoot)) ;
SETPARENT @ccomp TO (-1* ("נתן" MaybeClauseRoot)) ;

LIST ClauseCon = @conj @parataxis @xcomp ;
LIST NonQuote = N D ? ;
MAP @xcomp (MaybeClauseRoot Q) IF (-1* (MaybeClauseRoot Q) BARRIER NonQuote) (c ("כי" conj @mark)) ;
MAP (@conj ClauseRoot) (MaybeClauseRoot Q) IF (-1* (MaybeClauseRoot Q) BARRIER NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) (MaybeClauseRoot Q) IF (-1* (MaybeClauseRoot Q) BARRIER NonQuote) ;
MAP @xcomp MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) (c ("כי" conj @mark)) ;
MAP (@conj ClauseRoot) MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) ;
SETPARENT MaybeClauseRoot + ClauseCon + $$Domain (NOT p (*)) TO (-1* MaybeClauseRoot + $$Domain - @conj - @acl - @nmod - @xcomp) ;

LIST OblIsh = Time Cmpl Loca ;
MAP @obl Noun + OblIsh ;

SETPARENT @advmod + VerbInitial TO (-1* (verb MaybeClauseRoot)) ;
SETPARENT @advmod - VerbInitial TO (1* (verb MaybeClauseRoot) BARRIER (*) - @punct) ;
SETPARENT @advmod (NOT p (*)) TO (0* (verb MaybeClauseRoot) BARRIER CB) ;

SECTION

MAP @vocative Noun + (Voct) ;
SETPARENT @vocative TO (0* @root) ;

MAP @dislocated Noun + (CPen) ;
SETPARENT (@dislocated Frnt) TO (1* MaybeClauseRoot) ;

SECTION

LIST VerbArgs = @nsubj @obj @obl ;

SETPARENT VerbArgs (NOT p (*)) TO (0* (MaybeClauseRoot) BARRIER CB) ;

SECTION

SETPARENT @root TO (@0 (*)) ;
SETPARENT ("׃" @punct) TO (-1* @root) ;
SETPARENT Joiner TO (-1* (prep) OR (conj) BARRIER (*) - BD) ;
SETPARENT Joiner TO (1* @nsubj OR @advmod OR @compound:smixut BARRIER (*) - BD) ;

AFTER-SECTIONS
REMCOHORT (pb) ;
REMCOHORT (cb) ;
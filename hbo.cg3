DELIMITERS = "<׃>" ;

LIST PB = pb ;
LIST CB = cb ;
LIST BD = pb cb ;

LIST Det = art ;

LIST Pr = prep ;

LIST Sent = sent ;
LIST Cm = cm ;

LIST ClauseRoot = ClauseRoot ;

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;

LIST VerbInitial = Way0 WayX ;

LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;

LIST Joiner = ("׀" punct) ("־" punct) ;

LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ

# Universal Dependencies
# ======================

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @iobj = @iobj ;
LIST @appos = @appos ;
LIST @dep = @dep ;       # Any remaining dependency

SECTION # context-free mappings

MAP @punct (punct) ;
MAP @det Det ;
MAP @case Pr ;
MAP @nummod (card) OR (ordn) ;
MAP @compound:smixut Noun IF (-1* Noun + (c) - @nummod BARRIER (*) - Det - Joiner) ;
MAP @cc (conj) - (Rela) ;
MAP @cop (vbcp) IF (0* (PreC) BARRIER CB) ;
MAP @advmod (nega) ;
MAP @advmod (advb) ;
MAP @discourse (intj) ; # TODO: is there a better way to handle הנה?

SECTION # helper labels

LIST CanAddClauseRoot = PreC Pred ;
LIST CannotAddClauseRoot = @cop ClauseRoot @nummod ;
SET MaybeClauseRoot = CanAddClauseRoot - CannotAddClauseRoot ;
ADD ClauseRoot MaybeClauseRoot ;

#ADD (PreC ClauseRoot) (prn) - ClauseRoot IF (-1 (prep PreC)) ;

SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;

SECTION # adjacent words

LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;

SETPARENT @compound:smixut TO (-1* Noun) ;

SETPARENT (art @det) TO (1 (subs) OR (adjv) or (prde)) ;
MAP @det (prde) + $$AGen + $$ANum IF (-1 (art)) (-2 (subs det) + $$AGen + $$ANum) ;
SETPARENT (prde @det) TO (-2 (subs)) ;

SECTION # phrase-internal structure

MAP @amod (adjv) ; # TODO: adj as ClauseRoot, or is that covered by PreC?
SETPARENT @amod + $$AGen + $$ANum + $$ADet TO (-1* (subs) + $$AGen + $$ANum + $$ADet) ;

SETPARENT @nummod TO (0* Noun - @nummod BARRIER (*) - @nummod) ;

LIST YesCaseAble = subs (verb infc) prn nmpr prps prde ;
SET CaseAble = YesCaseAble - @nummod ;
SETPARENT @case TO (1* CaseAble BARRIER BD) ;

MAP @obj (prn) IF (-1 (verb)) ;
SETPARENT (prn @obj) TO (-1 (verb)) ;

# TODO: this should probably be stricter
MAP @iobj (prn PP Cmpl) IF (0 (*) LINK c ("ל" prep)) ;
SETPARENT (prn @iobj) TO (0* (verb)) ;

MAP @nmod:poss (prn) IF (-1 (subs)) ;
SETPARENT (prn @nmod:poss) TO (-1 (subs)) ;

SETPARENT @cc TO (1* CaseAble BARRIER BD) ;

SETPARENT CaseAble (NOT p (*)) TO (-1* BD LINK 1*A CaseAble BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @nmod CaseAble + (ppre) IF (p CaseAble) ;
MAP @appos CaseAble IF (p CaseAble) ;

MAP @conj (subs) IF (c @cc) (-1* CaseAble BARRIER BD LINK NOT p (*)) ;
MAP @nmod (subs) IF (c @case - ("את")) (-1* CaseAble BARRIER BD LINK NOT p (*)) ;
MAP @appos (subs) IF (NOT c @case) (NOT c @cc) (-1* CaseAble BARRIER BD LINK NOT p (*)) ;
LIST NounNoun = @nmod @conj @appos ;
SETPARENT (subs) + NounNoun (NOT p (*)) TO (-1* CaseAble BARRIER BD LINK NOT p (*)) ;

SECTION

MAP @obl Noun + (Adju a) ;

SET NonNmCl = (*) - (NmCl) - (prn) ;
LIST RelMark = ("אשׁר" conj) ;

MAP @acl (ClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
MAP @mark RelMark ;
SETPARENT (subs @acl) TO (-1* (subs) - (NmCl)) ;
SETPARENT RelMark + (NmCl) TO (1* @acl BARRIER NonNmCl) ;

SECTION

LIST SubjAble = subs prps nmpr prde ;

MAP @nsubj SubjAble + (Subj) ;
SETPARENT @nsubj TO (-1* (verb Pred) BARRIER (*) - Joiner - ("<prn>") - ("את" prep));

SETPARENT @cop TO (1* (ClauseRoot PreC)) ;
SETPARENT @nsubj TO (1* (ClauseRoot PreC) BARRIER CB) ;

SECTION # conjunction

SETPARENT (conj PP) TO (1* (subs PP)) ;
MAP @conj (subs PP) IF (0 (subs) LINK c @cc) ;
LIST CorC = (@conj) (@compound:smixut) ;
SETPARENT ("בין" subs PP @conj) TO (-1* ("בין" subs PP) - @conj) ;
SETPARENT (subs PP @conj) (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;
MAP @conj (subs NP) IF (0 (subs) LINK c @cc - (CP)) ;
SETPARENT (subs NP @conj) TO (-1* (subs NP) - @conj) ;

SECTION

SETPARENT (conj CP) TO (1* ClauseRoot) ;

SECTION

LIST Domain = N D Q ? ;

LIST ObjAble = subs prn nmpr ;

MAP @obj ObjAble + (Objc) ;
MAP @ccomp (verb infc Pred) IF (NOT -1* @ccomp) ;
MAP @ccomp (ClauseRoot Q) IF (NOT -1* (ClauseRoot Q) BARRIER (N)) ;
MAP @root ClauseRoot IF (NOT -1* ClauseRoot) ;
SETPARENT @obj TO (-1* (verb ClauseRoot)) ;

SETPARENT @ccomp TO (-1* ("אמר" ClauseRoot)) ;
SETPARENT @ccomp TO (-1* ("נתן" ClauseRoot)) ;

LIST ClauseCon = @conj @parataxis ;
MAP @parataxis (subs) + ClauseRoot + $$Domain IF (-1* ClauseRoot + $$Domain) (NOT c @nsubj) ; # TODO: also check for @csubj
MAP @conj ClauseRoot + $$Domain IF (-1* ClauseRoot + $$Domain) ;
SETPARENT ClauseRoot + ClauseCon + $$Domain TO (-1* ClauseRoot + $$Domain - @conj - @acl - @nmod) ;

LIST OblIsh = Time Cmpl Loca ;
MAP @obl Noun + OblIsh ;

SETPARENT @advmod + VerbInitial TO (-1* (verb ClauseRoot)) ;
SETPARENT @advmod - VerbInitial TO (1* (verb ClauseRoot) BARRIER (*) - @punct) ;

SECTION

MAP @vocative Noun + (Voct) ;
SETPARENT @vocative TO (0* @root) ;

SECTION

LIST VerbArgs = @nsubj @obj @obl ;

SETPARENT VerbArgs + $$ClauseType (NOT p (*)) TO (0* (ClauseRoot) + $$ClauseType BARRIER (*) - @punct - $$ClauseType + (CP)) ;

SECTION

SETPARENT @root TO (@0 (*)) ;
SETPARENT ("׃" @punct) TO (-1* @root) ;
SETPARENT Joiner TO (-1* (prep) OR (conj) BARRIER (*) - BD) ;
SETPARENT Joiner TO (1* @nsubj OR @advmod OR @compound:smixut BARRIER (*) - BD) ;

AFTER-SECTIONS
REMCOHORT (pb) ;
REMCOHORT (cb) ;
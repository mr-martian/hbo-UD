DELIMITERS = "<svb>" ;

####################
# Boundaries
####################

LIST PB = pb ;
LIST CB = cb ;
LIST SB = sb ;
LIST SVB = svb ;
LIST BD = pb cb sb svb ;
LIST Sent = ("׃" punct) ("נ" punct) ("פ" punct) ("ס" punct) ;
SET BDsent = BD OR Sent ;

####################
# POS
####################

LIST Det = art ;
LIST Pr = prep ;
LIST Joiner = ("׀" punct) ("־" punct) ;
SET NonJoiner = (*) - Joiner ;
LIST Noun = subs nmpr (verb ptcp) (verb ptca) ;
LIST RelMark = ("אשׁר" conj @mark) ("ה" conj CP Rela) ;
LIST Number = card ordn ;
LIST PRON = prde prps prn ;
LIST ADJ = adjv ;
LIST ADV = advb nega ;

####################
# Text-Fabric labels
####################

# Complete

LIST Function = Adju Cmpl Conj EPPr ExsS Exst Frnt Intj IntS Loca Modi ModS NCop NCoS Nega Objc PrAd PrcS PreC Pred PreO PreS PtcO Ques Rela Subj Supp Time Unkn Voct ;
LIST ClauseType = AjCl CPen Defc Ellp InfA InfC MSyn NmCl Ptcp Reop Unkn Voct Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX xIm0 XImp xImX XPos xQt0 XQtl xQtX xYq0 XYqt xYqX ZIm0 ZImX ZQt0 ZQtX ZYq0 ZYqX ; # feature typ
LIST AGen = m f ;
LIST ANum = sg du pl ;
LIST ADet = det und ;
LIST Domain = N D Q ? ;

# Subsets

LIST VavClause = Way0 WayX WIm0 WImX WQt0 WQtX WxI0 WXIm WxIX WxQ0 WXQt WxQX WxY0 WXYq WxYX WYq0 WYqX ;
LIST VerbInitial = Way0 WayX ;
LIST NonQuote = N D ? ;

####################
# Helper labels
####################

LIST HasConj = HasConj ;

LIST PPHead = PPHead ;
LIST NPHead = NPHead ;

LIST MaybeClauseRoot = MaybeClauseRoot ; # could be root of some clause
LIST ClauseRoot = ClauseRoot ; # is root of clause
LIST FullClauseRoot = FullClauseRoot ; # is root of non-relative clause
LIST TopClauseRoot = TopClauseRoot ; # is root of non-quoted clause

LIST Lemma = ".*"r ;
LIST Lemma2 = ".*"r ;

####################
# Universal Dependencies
####################

LIST @root = @root ;     # The root of the sentence, often a finite verb
LIST @nsubj = @nsubj ;   # The nominal subject of the sentence
LIST @amod = @amod ;       # 
LIST @advmod = @advmod ; # An adverbial modifier
LIST @case = @case ;     # The relation of an adposition to its head
LIST @acl = @acl ;       # A clause which modifies a nominal
LIST @nmod = @nmod ;     # Nominal modifier 
LIST @dobj = @dobj ;     # The direct object of the sentence
LIST @punct = @punct ;   # Any punctuation
LIST @cop = @cop ;       # 
LIST @nmod:poss = @nmod:poss ;
LIST @obl = @obl ;
LIST @obj = @obj ;
LIST @advcl = @advcl ;
LIST @aux = @aux ;
LIST @parataxis = @parataxis ;
LIST @det = @det ;
LIST @csubj = @csubj ;
LIST @nummod = @nummod ;
LIST @compound = @compound ;
LIST @compound:smixut = @compound:smixut ;
LIST @cc = @cc ;
LIST @conj = @conj ;
LIST @ccomp = @ccomp ;
LIST @mark = @mark ;
LIST @discourse = @discourse ;
LIST @vocative = @vocative ;
LIST @appos = @appos ;
LIST @dislocated = @dislocated ;
LIST @xcomp = @xcomp ;
LIST @flat = @flat ;
LIST @orphan = @orphan ;
LIST @dep = @dep ;       # Any remaining dependency

####################
# Special-case words
####################

LIST etNotAcc = NonAcc (Genesis w2857) (Genesis w2946) (Genesis w3165) (Genesis w3529) (Genesis w3560) (Genesis w3693) (Genesis w4172) (Genesis w4221) (Genesis w13880) (Ruth w897) (Ruth w901) ;

########################################
# INDIVIDUAL WORDS
########################################

BEFORE-SECTIONS

####################
# Corrections
####################

LIST MislabeledAsNarrative = w1404 w1405 w1423 w1424 w14251 w14252 w14253 (Ruth s5672) (Ruth s5673) ;
SUBSTITUTE (N) (Q) MislabeledAsNarrative ;

LIST UnknownShouldBeNarrative = (Genesis w2137) ;
SUBSTITUTE (?) (N) UnknownShouldBeNarrative ;

####################
# MWE names
####################

SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בית" wp1) ;
SUBSTITUTE (nmpr a) (subs c m retag:nmpr) ("בן" wp1) ;
SUBSTITUTE (nmpr) (subs retag:nmpr m) ("אל" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("לחם" wp2) ;
SUBSTITUTE (nmpr) (subs retag:nmpr) ("צדק" wp2) ;
SUBSTITUTE ("מלכי" nmpr) ("מלך" subs c retag:nmpr) (wp1 Genesis w6557) ;
SUBSTITUTE ("עמי" nmpr) ("עם" subs retag:nmpr has_prn) ("עמי" wp2) ;
SUBSTITUTE ("אוני" nmpr) ("און" subs retag:nmpr has_prn) ("אוני" wp2) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("עם" subs retag:nmpr) ;
ADDCOHORT ("<prn>" "אני" prn p1 sg) AFTER ("און" subs retag:nmpr) ;

####################
# Retagging
####################

# quotation
MERGECOHORTS ("<le'emor>" "$2$1"v SCONJ *) ("(אמר)"r verb infc) WITH (-1 ("(ל)"r prep)) ;

# Substantivized adjectives
SUBSTITUTE (adjv) (subs retag:adjv) (c) ;
SUBSTITUTE (adjv) (subs retag:adjv) (a) (1 BD) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv a) (1 (prn)) ;
# TODO: does this really apply to all gentillics?
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl pl) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (-1* Noun + (c) BARRIER NonJoiner - Det) ;
SUBSTITUTE (adjv) (subs retag:adjv) (adjv gntl) (NEGATE 0* (subs) OR (nmpr) BARRIER PB) ;

# Participles in smixut
LIST Participle = ptca ptcp ;
LIST NPish = NP PP ;
SUBSTITUTE (verb) (subs retag:verb) Participle + NPish ;

# Adverbs tagged subs
SUBSTITUTE (subs) (advb retag:subs) (padv) - (NP) (-1 BD) (1* BD BARRIER (*) - (punct)) ;

# Determiner on clause participles
SUBSTITUTE (art) (conj retag:art) (CP Rela) ;

# Prepositions tagged as nouns
SUBSTITUTE (subs) (advb retag:subs) ("אחר" subs ppre AdvP) (1 BD) ;
SUBSTITUTE (subs) (prep retag:subs) ("אחר" subs ppre) ;

# yesh and ein
SUBSTITUTE (subs) (verb retag:subs MaybeClauseRoot ClauseRoot) (nmcp) ;

# interrogative adverbs
LIST ItgAdv = "מתי" "איפה" ;
SUBSTITUTE (inrg) (advb retag:inrg) ItgAdv ;

####################
# Helper labels
####################

ADD (NonAcc) ("את" prep Cmpl) + $$ClauseType - (NonAcc)
    IF (0* ("את" prep Objc) + $$ClauseType BARRIER SB) ;

####################
# Consistent labels
####################

MAP @punct (punct) ;
MAP @det Det ;
LIST SCONJ = "כי" "פן" "אשׁר" "אם" "שׁ" "ה" ; # TODO: double check שׁ which only appears once
MAP @mark SCONJ + (conj CP) ;
MAP @mark ("ה" inrg) ;
MAP @obj ("את") + Pr IF (1 RelMark) ;
MAP @obl Pr IF (1 RelMark) ;
MAP @case Pr ;
MAP @cc (conj) - (Rela) ;
MAP @advmod ADV ;
MAP @advmod ("למה" inrg) ;
MAP @discourse (intj) ; # TODO: is there a better way to handle הנה?

####################
# Pronoun suffixes
####################

SUBSTITUTE ("prn") ("אני") ("prn" prn p1 sg) ;
SUBSTITUTE ("prn") ("אנחנו") ("prn" prn p1 pl) ;
SUBSTITUTE ("prn") ("אתה") ("prn" prn p2 m sg) ;
SUBSTITUTE ("prn") ("את") ("prn" prn p2 f sg) ;
SUBSTITUTE ("prn") ("אתם") ("prn" prn p2 m pl) ;
SUBSTITUTE ("prn") ("אתן") ("prn" prn p2 f pl) ;
SUBSTITUTE ("prn") ("הוא") ("prn" prn p3 m sg) ;
SUBSTITUTE ("prn") ("היא") ("prn" prn p3 f sg) ;
SUBSTITUTE ("prn") ("הם") ("prn" prn p3 m pl) ;
SUBSTITUTE ("prn") ("הן") ("prn" prn p3 f pl) ;

########################################
# PHRASES
########################################

SECTION

####################
# Pronoun suffixes
####################

LIST NsubjPrn = ExsS ModS NCoS PrcS PreS ;
LIST ObjPrn = PreO PtcO ;
MAP @nsubj (prn) + NsubjPrn ;
MAP @obj (prn) + ObjPrn ;
MAP @obj (prn) IF (-1 (verb)) ;
MAP (NPHead @obj) (prn) IF (-1 Pr + ("את") - etNotAcc) ;
SETPARENT (prn @obj) OR (prn @nsubj) (NOT p (*)) TO (-1 (verb)) ;
MAP @nmod:poss (prn) IF (-1 Noun - (verb) - Number) ;
SETPARENT @nmod:poss (NOT p (*)) TO (-1 Noun) ;
MAP @nmod (prn) IF (-1 Number) ;
SETPARENT (prn @nmod) (NOT p (*)) TO (-1 Number) ;

####################
# Numbers
####################

LIST BigNumber = "עשׂרה" "מאה" "עשׂר" ;
MAP @flat BigNumber + Number IF (-1* Number BARRIER NonJoiner) ;
SETPARENT @flat + Number (NOT p (*)) TO (-1* Number BARRIER NonJoiner) ;
MAP @conj Number IF (-1* @cc BARRIER NonJoiner LINK -1* Number BARRIER NonJoiner - @flat) ;
SETPARENT @cc (NOT p (*)) TO (1 Number + @conj) ;
#SETPARENT Number (NOT p (*)) TO (1 (prn)) ;
SETPARENT Number + @conj (NOT p (*))
    TO (-1* Number - @flat BARRIER NonJoiner - @cc - @flat) ;
SETPARENT Number + (c) (NOT p (*)) TO (1* Noun - Number BARRIER NonJoiner - Det) ;
SETPARENT Number (NOT p (*)) TO (-1 Noun - Number) ;
SETPARENT Number (NOT p (*))
    TO (1* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
SETPARENT Number (NOT p (*))
    TO (0* Noun - Number BARRIER NonJoiner - Det - Number - @cc) ;
MAP @nummod Number IF (p Noun OR (prn)) (NEGATE c @nmod) ;

####################
# Smixut
####################

# conjunction within smixut
# (kinda weird, but arg structure doesn't make sense otherwise)
MAP @conj $$Lemma + (subs) IF (-1* NonJoiner LINK 0 @cc LINK -1* NonJoiner - (prn) LINK 0 $$Lemma + (subs)) ;
SETPARENT @conj + $$Lemma + (subs) (NOT p (*))
    TO (-1* NonJoiner LINK 0 @cc LINK -1* NonJoiner - (prn) LINK 0 $$Lemma + (subs)) ;
SETPARENT @cc (NOT p (*)) TO (1 (subs @conj)) ;

MAP @compound:smixut Noun IF (-1* Noun + (c) - Number BARRIER NonJoiner - Det - @nummod - @flat) ;
SETPARENT @compound:smixut (NOT p (*)) TO (-1* Noun) ;

####################
# Determiners
####################

SET DetAble = Noun OR ADJ OR PRON ;
SETPARENT Det (NOT p (*)) TO (1 DetAble) ;
LIST PrnMaybeDet = prde (prps p3) ;
MAP @det PrnMaybeDet IF (-1 Det LINK -1* Noun BARRIER NonJoiner) ;
SETPARENT @det (NOT p (*)) TO (-1* Noun BARRIER NonJoiner - Det) ;

####################
# Adjectives
####################

SET AdjNonBar = NonJoiner - (nega) ;
SETPARENT (nega) (NOT p (*)) TO (1* ADJ BARRIER NonJoiner) ;
MAP @conj ADJ IF (-1* @cc BARRIER AdjNonBar LINK -1* ADJ BARRIER AdjNonBar) ;
MAP @conj ADJ IF (-1* ADJ BARRIER AdjNonBar)
                 (1* @cc BARRIER AdjNonBar LINK 1* ADJ BARRIER AdjNonBar) ;
SETPARENT ADJ + @conj (NOT p (*))
    TO (-1* ADJ - @conj BARRIER AdjNonBar - @cc) ;
SETPARENT @cc (NOT p (*)) (-1* ADJ BARRIER NonJoiner) TO (1* ADJ BARRIER AdjNonBar) ;

SETPARENT ADJ + $$AGen + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$AGen + $$ANum + $$ADet BARRIER PB OR Pr) ;
SETPARENT ADJ + $$ANum + $$ADet (NOT p (*))
    TO (-1* Noun + $$ANum + $$ADet - AGen BARRIER PB OR Pr) ;
MAP @amod ADJ IF (p Noun) ;

LIST BetterHeads = Pred Subj Objc PreC PreO ;
UNMAP @advmod IF (NOT 0 (MSyn)) (NEGATE 0* BetterHeads BARRIER SB) ;
LIST AdvIsh = (advb AdvP) (nega NegP) ;
ADD (MaybeClauseRoot ClauseRoot) AdvIsh - (ClauseRoot) ;

####################
# Prepositions
####################

LIST CaseAbleAdv = "כן" "שׁם" "פה" "שׁם" "הלאה" "הנה" "עתה" "אז" ;
LIST NumberLabel = @nummod @conj @flat ;
SET ProbablyNumber = Number + NumberLabel ;
SET CaseAble = Noun - ProbablyNumber OR PRON OR (verb infc) OR (verb infa) OR CaseAbleAdv + ADV OR (prin) OR (inrg);
SET AfterPrep = Det OR @case OR @nummod OR @cc OR ProbablyNumber ;
SETPARENT @case (NOT p (*)) TO (1* CaseAble BARRIER NonJoiner - AfterPrep) ;
SETPARENT @case (NOT p (*)) TO (1*A ADJ BARRIER NonJoiner - AfterPrep LINK NOT p (*)) ;

####################
# Label NP heads
####################

ADD PPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead) (c @case - ("את") OR etNotAcc) ;
ADD NPHead Noun OR PRON OR ADJ IF (NOT p (*)) (NOT 0 PPHead OR NPHead) ;

####################
# NP/PP conjunctions
####################

SETPARENT REPEAT @cc (NOT p (*)) TO (1* NPHead OR PPHead BARRIER PB) ;
ADD REPEAT HasConj NPHead OR PPHead IF (NOT 0 HasConj) (c @cc) ;

####################
# NP/PP adverbs
####################

LIST NPIsh = NP PPrP PP PrNP PreO ;
SETPARENT @advmod + NPIsh TO (1* NPHead OR PPHead BARRIER PB) ;

####################
# Apposition
####################

MAP REPEAT @appos NPHead - HasConj - (nmpr) IF (-1* NPHead OR PPHead BARRIER BD) ;
LIST Titles = "בכר" ;
MAP REPEAT @appos NPHead - HasConj + (nmpr) IF (-1* NPHead + Titles BARRIER BD OR NPHead OR PPHead) ;

####################
# VP
####################

MAP @acl (verb infc VP) IF (-1 (subs c)) ;
SETPARENT (verb infc VP @acl) (NOT p (*)) TO (-1 (subs c)) ;

SETPARENT @cc (NOT p (*)) (-1 (infa)) TO (1 (infa)) ;
MAP @conj (infa) IF (c @cc) ;
SETPARENT (infa) (NOT p (*)) (c @cc) TO (-2 (infa)) ;
MAP @advcl (infa AdvP) IF (NOT 1 BD) ;

MAP @obl ("בלת" subs) ;
SETPARENT ("בלת" @obl) (NOT p (*)) TO (1* (infc) BARRIER NonJoiner) ;

LIST Inf = (infc InfC) PrepVerb ;

####################
# Connect NPs
####################

SET NonAppos = NPHead - @appos ;

MAP REPEAT @conj PPHead + HasConj IF (-1* PPHead BARRIER BD OR NonAppos) ;
MAP REPEAT @conj PPHead IF (-1* PPHead BARRIER BD OR NonAppos)
                           (1* PPHead + HasConj BARRIER BD OR NonAppos) ;

SECTION
SETPARENT PPHead + @conj (NOT p (*))
    TO (-1* PPHead - @conj BARRIER BD OR NonAppos) ;

SECTION
LIST ApposOverride = (w93 Ruth) (w189 Genesis) (Genesis w14323) ;
LIST ConjToAppos = w36714 (w7950 Exodus) (w95 Ruth) (w215 Genesis) (w313 Genesis) (Genesis w303) ;
LIST ConjToSmixut = (Genesis w734) ;
MAP @appos ApposOverride;
SETPARENT CaseAble + ConjToAppos TO (-1* @appos) ;
SETPARENT CaseAble + ConjToSmixut TO (-1* @compound:smixut) ;
MAP @conj NPHead + HasConj IF (-1* NonAppos BARRIER BD) ;
MAP @conj NPHead IF (-1* NonAppos BARRIER BD) (1* NPHead + HasConj BARRIER BD) ;
SETPARENT NPHead + @conj (NOT p (*)) TO (-1* NonAppos - @conj BARRIER BD) ;

# TODO: any better way to do this?
SETPARENT (w189 Genesis) (NOT p (*)) TO (-1* (w185)) ;
SETPARENT (Genesis w14323) (NOT p (*)) TO (-1* (prn)) ;

LIST Family = "בן" "בת" "אב" "כלה" "אשׁה";
SETPARENT Family + (subs) (NOT p (*)) TO (-1 (nmpr a)) ;

LIST ApposToLastGen = w265 w297 w307 w640 w648 w734 w1966 w11294 w12466 w12610 w12711 w13874 w14590 w14649 w18761 w18788 w19072 ;
LIST ApposToLastRut = w19 w50 w93 ;
SET ApposToLast = ApposToLastGen + (Genesis) OR ApposToLastRut + (Ruth) ;
LIST ApposAble = subs nmpr prn ;
SETPARENT CaseAble + ApposToLast (NOT p (*)) TO (-1* ApposAble - (wp2)) ;
SETPARENT CaseAble - ApposToLast - ConjToAppos (NOT p (*))
     TO (-1* BD LINK 1*A CaseAble - @compound:smixut BARRIER BD LINK NOT p (*)) ;
MAP @conj CaseAble IF (c @cc) (p CaseAble) ;
MAP KEEPORDER @appos CaseAble IF (c @case + $$Lemma) (p CaseAble LINK c @case + $$Lemma) ;
MAP @nmod CaseAble IF (c @case - ("את")) (p CaseAble) ;
MAP @appos CaseAble IF (p CaseAble) ;

SETPARENT PPHead (NOT p (*)) TO (-1* NPHead BARRIER PB) ;
MAP @nmod PPHead IF (p NPHead) ;

LIST NorP = NPHead PPHead ;
SETPARENT NPHead + @appos (NOT p (*)) TO (-1* NorP - @appos BARRIER BD) ;

SETPARENT (/^\(c\\d+\)$/r) + (Objc HasConj) (NOT p (*)) TO (-1* (VSTR:$1) + (NPHead Objc) - (HasConj) - @appos) ;

####################
# Other labels
####################

MAP @cop (vbcp) + $$ClauseType OR (aux nmcp) IF (0* (PreC) + $$ClauseType BARRIER SB) ;
SETPARENT @cop + $$ClauseType (NOT p (*)) TO (0* (PreC) + $$ClauseType + NorP BARRIER SB) ;

SECTION # conjunction

SETPARENT (conj PP) (NOT p (*)) TO (1* (subs PP)) ;
MAP @conj (subs PP) - (PreC) - MaybeClauseRoot IF (0 (subs) LINK c @cc) (NOT c @cop) ;
LIST CorC = (@conj) (@compound:smixut) ;
SETPARENT ("בין" subs PP @conj) TO (-1* ("בין" subs PP) - @conj) ;
SETPARENT (subs PPHead @conj) - ClauseRoot (NOT p (*)) TO (-1* (subs PP) - @conj - @compound:smixut) ;

SETPARENT (conj NP) (NOT p (*)) TO (1* (subs NP)) ;
MAP @conj (subs NP) IF (0 (subs) LINK c @cc - (CP)) ;

SECTION # helper labels

LIST MCR = MaybeClauseRoot ;
TEMPLATE MCRp = (NOT 0 MCR LINK NEGATE 0* MCR BARRIER CB) ;

ADD MCR (ClausePhraseRoot) - MCR + (/^(c\\d+\)$/r) IF (NEGATE -1* (VSTR:$1) + MCR) ;

# irregular conjunction attachment
SETPARENT (Genesis w11903) (NOT p (*)) TO (1* (Genesis w11910)) ;

LIST NoGlom = prep ;

SETPARENT (/^\(c\\d+\)$/r) - MCR - NoGlom (NOT p (*)) TO (0* (VSTR:$1) + MCR) ;

LIST SubjIsh = Subj (IntS prn) ;
MAP @nsubj SubjIsh - MCR IF (p MCR LINK NEGATE c @nsubj) ;
MAP @dislocated (Subj) - MCR IF (p MCR) ;
MAP @obj (Objc) - MCR IF (p MCR LINK NEGATE c @obj) ;
MAP @xcomp (Objc) - MCR OR (PrAd) - MCR IF (p MCR) ;

MAP @advmod (verb infa) + $$Lemma - MCR IF (p MCR + $$Lemma) ;

LIST OblIsh = Time Cmpl Loca Modi Adju Supp (Conj PPHead) ;
MAP @orphan OblIsh + (Ellp) - MCR IF (p MCR + (Ellp)) ;
MAP @obl OblIsh - MCR IF (p MCR) ;

ADD MCR (Pred) - (vbcp) - MCR ;
LIST PredIsh = PreC PrcS PrAd PreO PreS PtcO ;
ADD MCR PredIsh IF (T:MCRp) ;
LIST CopIsh = (Pred vbcp) NCop NCoS ;
LIST NonCopIsh = (Genesis w1955) ;
ADD MCR CopIsh - NonCopIsh IF (T:MCRp) ;

SECTION # clause con

SET PlainC = MCR - (HasMark) - (HasRel) ;
SET PlainNC = PlainC - (HasConj) ;

LIST MarkOverride = (Genesis w14455) ;

ADD (HasConj) MCR - (HasConj) IF (c @cc) ;
ADD (HasMark) MCR - (HasMark) + (infc) IF (c @case) ;
ADD (HasMark) MCR - (HasMark) IF (c @mark - (inrg ques) - (SCONJ) - (Rela) - RelMark) ;
ADD (HasMark) MCR + MarkOverride - (HasMark) ;
ADD (HasRel) MCR - (HasRel) IF (c @mark + (Rela) OR RelMark) ;

SECTION

LIST PreMark = (Genesis w11906) (Genesis w16927) (Genesis w17650) (Genesis w28321) (Ruth w1212) (Ruth w1206) ;
LIST PostMark = (Ruth w948) (Ruth w1301) ;
LIST NestMark = (Genesis w13723) (Genesis w16271) (Genesis prn c32626) (Genesis w21741) (Genesis w25551) (Ruth w122) (Ruth w127) (Ruth w1181) ;
LIST MarkToAcl = (Genesis w1848) (Genesis w19068) (Genesis w26087) (Ruth w714) ;

SETPARENT (HasMark HasConj) (NOT p (*))
    TO (-1* (HasMark) - (HasConj) BARRIER PlainC) ;
MAP @conj (HasMark HasConj) - NestMark IF (p (HasMark)) ;

LIST Ptc = ptcp ptca infc ;

SETPARENT (verb) + Ptc - (SCONJ) (NOT p (*)) TO (-1* Noun - @compound:smixut BARRIER NonJoiner - BD - @det - @compound:smixut) ;
MAP @acl (verb) + Ptc IF (p Noun) ;

LIST XcompInf = "יסף" "יכל" "חפץ" "מהר" "אמץ" "חדל" "כלה" "ירא" "מלא" "חלל" ;
MAP @xcomp (verb infc InfC) IF (-1* XcompInf + (verb) BARRIER SB OR @mark) ;

MAP @xcomp (NPHead PreC) IF (0* (vbcp infc InfC) BARRIER CB LINK -1* XcompInf + (verb) BARRIER SB OR @mark) ;
MAP @cop (vbcp) IF (p (PreC)) ;

SETPARENT (@xcomp InfC) (NOT p (*)) TO (-1* XcompInf + (verb) BARRIER SB) ;

MAP @cop (vbcp) IF (1* Participle OR (infc) BARRIER (*) - BD - ("ל" prep)) ;
SETPARENT @cop (NOT p (*)) TO (1* Participle OR (infc) BARRIER (*) - BD - ("ל" prep)) ;

MAP @advcl (infc) IF (-1 ("ל" prep) LINK -1* (verb nmcp) BARRIER SB) ;
MAP @xcomp Participle - (Subj) IF (-1* (verb nmcp) BARRIER SB) ;
SETPARENT @advcl OR @xcomp (NOT p (*)) TO (-1* (verb nmcp) BARRIER SB) ;

SECTION

SETPARENT MarkToAcl (NOT p (*)) TO (0* MCR + (HasRel)) ;
SETPARENT NestMark (NOT p (*)) TO (0* MCR + (HasMark)) ;
SETPARENT PreMark (NOT p (*)) TO (1* MCR - (HasMark)) ;
SETPARENT PostMark (NOT p (*)) TO (-1* MCR - (HasMark)) ;
SETPARENT (HasMark) (NOT p (*))
    TO (0* PlainC BARRIER MCR - (HasMark) - (HasRel) OR SB) ;

LIST CcompVerb = "ראה" "ירא" ;
LIST XcompVerb = "נחם" "שׁחת" "קרא" "מלא" "לבשׁ" "שׁחת" "נגד" "ידע" "מהר" "יכל" "חדל" "אמץ" "כלה" ;
LIST AdvclMarkVerb = "קרא" ;
LIST PrAdvcl = "עד" ;

LIST AdvclAble = ("כי" conj @mark) ("אם" conj @mark) ;
LIST ActuallyCcomp = (w351 Genesis) (Genesis w7129) (Ruth w1243) ;
LIST ActuallyAdvcl = (Genesis w16459) (Genesis w26044) ;

SETPARENT (SCONJ @mark) (NOT p (*)) TO (1* (FullClauseRoot Q)) ;

SETPARENT MaybeClauseRoot + $$Domain (c AdvclAble) (NOT p (*))
    TO (-1* PlainC + $$Domain BARRIER Domain - $$Domain) ;
SETPARENT (verb infc) + $$Domain - (SCONJ) (NEGATE c @cc) (NOT p (*))
    TO (-1* MaybeClauseRoot + $$Domain BARRIER Domain - $$Domain) ;

MAP @ccomp ActuallyCcomp ;
MAP @advcl ActuallyAdvcl ;
MAP @advcl MaybeClauseRoot IF (c PrAdvcl + @case) ;
MAP @advcl MaybeClauseRoot IF (c AdvclAble) (p AdvclMarkVerb) ;
MAP @xcomp MaybeClauseRoot IF (c AdvclAble) (p XcompVerb) ;
MAP @xcomp MaybeClauseRoot IF (c AdvclAble) (p CcompVerb LINK c @obj) ;
MAP @ccomp MaybeClauseRoot IF (c AdvclAble) (p CcompVerb) ;
MAP @advcl MaybeClauseRoot IF (c AdvclAble) (p (*)) ;
MAP @advcl (PrepVerb) IF (p (*)) ;

LIST OrphanInfc = (Genesis w18716) ;
MAP @advcl MCR + (HasMark) - OrphanInfc IF (p MCR) ;

ADD FullClauseRoot MCR - (HasMark) - (HasRel) - @acl - FullClauseRoot ;

SECTION

SETPARENT FullClauseRoot + (HasConj) + $$Domain (NOT p (*))
    TO (-1* FullClauseRoot - (HasConj) + $$Domain BARRIER FullClauseRoot - $$Domain) ;

MAP @conj FullClauseRoot + (HasConj) IF (p FullClauseRoot) ;

MAP @conj Inf IF (c @cc LINK -1* Inf BARRIER SB OR MaybeClauseRoot - Inf) ;
SETPARENT Inf + @conj (NOT p (*))
    TO (c @cc LINK -1* Inf - @conj BARRIER SB OR MaybeClauseRoot - Inf) ;

SECTION # adjacent words

LIST SmallQstQ = inrg prin ;
LIST SmallQstPrn = prde prn ;
MAP @nsubj SmallQstQ - MaybeClauseRoot IF (-1 BD) (1* SmallQstPrn BARRIER NonJoiner LINK 1 BDsent) ;

SECTION # phrase-internal structure

ADD (ClauseRoot) (adjv AjCl) - (ClauseRoot) IF (NOT p (*)) ;
LIST AdjNonAcl = (Genesis w23609) ;
MAP @acl (ClauseRoot AjCl) - AdjNonAcl
    IF (-1* CB BARRIER SB OR @mark LINK -1* NPHead BARRIER BD) ;

SECTION

MAP @obl Noun + (Adju a) ;
MAP @obl PPHead + (PreC) IF (-1* (nmcp) BARRIER SB) ;

SET NonNmCl = (*) - (NmCl) - (prn) ;

MAP @acl (MaybeClauseRoot NmCl) IF (-1* RelMark BARRIER CB) ;
LIST AclChain = (Genesis w603) ;
SETPARENT @acl + AclChain (NOT p (*)) TO (-1* @acl LINK p (*)) ;
SETPARENT (subs @acl) - AclChain (NOT p (*)) TO (-1* Noun - (verb) OR Pr + @obj OR Pr + @obl) ;

LIST RelSkip = (Ruth w550) ;
SETPARENT @acl (NOT p (*)) TO (-1* NorP - RelSkip BARRIER SB) ;

SECTION

LIST SubjAble = subs prps nmpr prde prn prin ;

LIST ExtraSubj = (Ruth w25) ;
MAP @nsubj SubjAble + (Subj) ;

LIST VerbArgs = @nsubj @obj @obl @vocative (@xcomp adjv) (@advcl infa) (@advcl infc) @advmod ;
SETPARENT VerbArgs + $$ClauseType - Pr (NOT p (*))
    TO (0* ClauseRoot + $$ClauseType BARRIER SB) ;
SETPARENT VerbArgs + $$ClauseType - Pr (NOT p (*))
    TO (0* MaybeClauseRoot + $$ClauseType BARRIER SB) ;

SECTION

SETPARENT (conj CP) (NOT p (*)) TO (1 PB LINK 1 @cop LINK p (*)) ;
SET CorR = (conj CP) OR RelMark ;
SET CorM = ClauseRoot OR MaybeClauseRoot OR (nmcp) - @cop ;
LIST ConjTypes = CPen NmCl MSyn ;
SETPARENT CorR + $$ClauseType (NOT p (*)) TO (1* CorM + $$ClauseType) ;
MAP @acl MaybeClauseRoot IF (c RelMark) ;
LIST AclAble = subs adjv ptcp ptca nmpr ;
LIST AclCompOk = (Exodus w3801) (Exodus w5417) ;
LIST AclCompNotOk = (Genesis w12528) (Genesis w12613) (Ruth w712) ;
LIST AclMultiTarget = (Genesis w391) ;
SETPARENT @acl (NOT p (*)) TO (-1* AclMultiTarget BARRIER SB) ;
SETPARENT @acl (NOT p (*)) TO (c @mark LINK -1 Pr) ;
SETPARENT @acl + AclCompNotOk (NOT p (*))
    TO (-1* CB LINK -1* AclAble - @compound:smixut BARRIER BD) ;
SETPARENT @acl - AclCompNotOk - AclChain (NOT p (*))
    TO (-1* CB LINK -1* AclAble - @nummod BARRIER BD) ;

MAP @advmod (verb infa) IF (1* PB BARRIER NonJoiner LINK 1 (verb)) ;

MAP @ccomp (SCONJ verb) IF (NEGATE 1* MaybeClauseRoot) ;
MAP @mark (SCONJ verb) ;

SECTION

LIST ObjAble = subs prn nmpr prin prde ;

ADD (ProbablyObj) ObjAble + (Objc) - (ProbablyObj) ;

ADD (MaybeClauseRoot ClauseRoot) (ProbablyObj Ellp) - ClauseRoot ;

SECTION

LIST ObjIsh = @obj ProbablyObj ;
LIST XcompOverride = (Genesis w17124) ;
MAP @xcomp XcompOverride ;
MAP @obj (ProbablyObj) + $$ClauseType - ClauseRoot IF (NEGATE -1* ObjIsh + $$ClauseType BARRIER SB) ;

LIST OrphanPrepVerb = (Genesis w18716) ;
ADD (PrepVerb) (verb) - (PrepVerb) - OrphanPrepVerb IF (c @case OR ("בלת" @obl)) ;

LIST XorO = (@xcomp ProbablyObj) @obj ;
SETPARENT XorO + $$ClauseType (NOT p (*))
    TO (0* MaybeClauseRoot + $$ClauseType BARRIER SB) ;

ADD (MaybeClauseRoot ClauseRoot) (*) - ClauseRoot IF (c @nsubj) ;

SECTION

LIST PrepVerbChain = (Genesis w13720) (Genesis w16269) ;

SETPARENT (PrepVerb) (NOT p (*))
    TO (0* MaybeClauseRoot - (PrepVerb) OR PrepVerbChain BARRIER SB) ;
MAP @advcl (PrepVerb) IF (p (*)) ;

LIST SpeakingVerb = quot "ברך" "צוה" "נגד" "דבר" "ענה" ;

LIST AdvclOverride = (Ruth w1187) ;
MAP @advcl AdvclOverride ;

ADD (MaybeClauseRoot ClauseRoot) NPHead OR PPHead IF (c @mark) ;
SETPARENT CorR + ConjTypes + @mark (NOT p (*)) TO (1* CorM) ;

MAP @advcl (MaybeClauseRoot Q)
    IF (c @mark - (inrg ques) - (SCONJ)) (1* (MaybeClauseRoot Q) BARRIER NonQuote LINK NEGATE c @mark) ;
MAP (ClauseRoot @ccomp) (subs MaybeClauseRoot)
    IF (c (vbcp infc Pred)) (NOT -1* @ccomp) ;
SET MSynIsh = CorR + @cc OR @advmod ;
SETPARENT MSynIsh + ConjTypes (NOT p (*)) TO (1* CorM - @advcl) ;
MAP @conj (MaybeClauseRoot Q)
    IF (c @cc) (-1* (MaybeClauseRoot Q) - @acl - @advcl BARRIER (N)) ;
MAP @parataxis (MaybeClauseRoot Q) - (infc)
    IF (NEGATE c @cc) (NEGATE c @mark)
       (-1* (MaybeClauseRoot Q) - @acl - @advcl BARRIER (N)) ;
MAP @ccomp (MaybeClauseRoot Q)
    IF (NEGATE c @mark) (-1* MaybeClauseRoot + NonQuote)
       (NOT -1* (MaybeClauseRoot Q) - @acl BARRIER (N)) ;
LIST CRconj = @ccomp @root @parataxis ;
SETPARENT (MaybeClauseRoot Q HasConj) - (HasMark) (NOT p (*))
    TO (-1* (MaybeClauseRoot Q) - (HasConj) - (HasMark) - (HasRel) BARRIER MaybeClauseRoot + NonQuote) ;
SETPARENT (MaybeClauseRoot Q @conj) (NOT p (*))
    TO (-1* (MaybeClauseRoot Q) + CRconj) ;

MAP @root MaybeClauseRoot IF (NOT -1* MaybeClauseRoot - @advcl - @acl) ;

SETPARENT @advcl + $$Domain (NOT p (*)) TO (1* MaybeClauseRoot + $$Domain BARRIER SB) ;
SETPARENT @advcl + $$Domain (NOT p (*)) TO (-1* MaybeClauseRoot + $$Domain BARRIER SB) ;
SETPARENT @advcl + $$Domain (NOT p (*)) (NEGATE 0* MaybeClauseRoot BARRIER SB) TO (1* MaybeClauseRoot + $$Domain - @advcl) ;

SETPARENT (@ccomp Q) (NOT p (*)) TO (-1* (quot MaybeClauseRoot) - @mark) ;
LIST CcompAble = "חלל" "נתן" "מהר" "צוה" "שׁמע" ;
SETPARENT @ccomp (NOT p (*)) TO (-1* CcompAble + MaybeClauseRoot) ;

LIST ClauseCon = @conj @parataxis @xcomp ;
MAP (@conj ClauseRoot) MaybeClauseRoot + $$NonQuote IF (-1* MaybeClauseRoot + $$NonQuote) (c @cc) ;
MAP (@parataxis ClauseRoot) MaybeClauseRoot + $$NonQuote - (PrepVerb) IF (-1* MaybeClauseRoot + $$NonQuote) ;

LIST ConjToAdvcl = (Genesis w772) ;
SETPARENT ConjToAdvcl (NOT p (*)) TO (-1* MaybeClauseRoot + @advcl) ;

LIST DontConj = @conj @acl @nmod @xcomp @appos @advcl @nmod:poss (@ccomp N) @obl @mark ;
SETPARENT MaybeClauseRoot + ClauseCon + $$Domain (NOT p (*)) TO (-1* MaybeClauseRoot + $$Domain - DontConj) ;

MAP @obl Noun + OblIsh ;

SETPARENT @advmod + VerbInitial (NOT p (*)) TO (-1* (verb MaybeClauseRoot)) ;

SECTION

MAP @dislocated SubjAble + (CPen) ;
SETPARENT (@dislocated Frnt) (NOT p (*)) TO (-1* @mark BARRIER (*) - BD LINK p (*)) ;
SETPARENT (@dislocated Frnt) (NOT p (*)) TO (1* MaybeClauseRoot - @advcl) ;

SECTION

MAP @vocative Noun + (Voct) ;
MAP @obl PPHead - ClauseRoot ;

MAP @xcomp (NPHead adjv) - FullClauseRoot ;

SETPARENT Pr + VerbArgs (NOT p (*)) TO (-1* (verb)) ;

SETPARENT @nsubj (NOT p (*)) TO (0* @cop BARRIER CB LINK p (*)) ;

SETPARENT VerbArgs (NOT p (*))
    TO (c @acl LINK 1* CB LINK 1* MaybeClauseRoot BARRIER CB OR SB) ;

SETPARENT VerbArgs + $$ClauseType (NOT p (*))
    TO (0* MaybeClauseRoot + $$ClauseType BARRIER SB) ;

SETPARENT @mark (NOT p (*)) TO (1* (ClauseRoot) OR MaybeClauseRoot) ;

SECTION

SETPARENT @root TO (@0 (*)) ;

SETPARENT @vocative + (Q) (NOT p (*)) TO (0* MaybeClauseRoot + (Q) BARRIER SB) ;
SETPARENT @vocative + $$Domain (NOT p (*)) TO (0* MaybeClauseRoot + $$Domain) ;
SETPARENT @vocative (NOT p (*)) TO (-1* ClauseRoot) ;

SETPARENT @discourse (NOT p (*))
    TO (1* @nsubj BARRIER NonJoiner - BD LINK p (*)) ;
SETPARENT @discourse (NOT p (*)) TO (1* (verb) BARRIER (*) - PB - CB) ;

SECTION

SETPARENT MCR + (Q) (NOT p (*)) (c (SCONJ)) TO (-1* SpeakingVerb BARRIER PlainC + (N) - (SCONJ)) ;
SETPARENT MaybeClauseRoot + (Q) (NOT p (*)) (c (SCONJ)) TO (-1* PlainC + (N)) ;
SETPARENT MaybeClauseRoot + (Q) (NOT p (*)) TO (-1* SpeakingVerb OR MaybeClauseRoot - @conj OR @root) ;
SETPARENT (SCONJ @ccomp) (NOT p (*)) TO (-1* SpeakingVerb) ;
SETPARENT MaybeClauseRoot - @acl (NOT p (*)) TO (-1* @root) ;
MAP @conj MaybeClauseRoot IF (c @cc) (p @root) ;
MAP @ccomp MaybeClauseRoot + (Q) IF (p SpeakingVerb) ;
MAP @ccomp MCR + (Q) IF (p (N)) (c (SCONJ)) ;
MAP @parataxis MaybeClauseRoot IF (p MaybeClauseRoot) (NEGATE c @cc) ;

AFTER-SECTIONS

UNMAP @nsubj IF (NOT p (*)) ;
MAP @dislocated SubjAble + (Subj) ;
SETPARENT @dislocated (NOT p (*)) TO (-1* ClauseRoot) ;

#UNMAP @case IF (p (verb)) ;
#MAP @mark Pr IF (p (verb)) ;

REMCOHORT (pb) ;
REMCOHORT (cb) ;
REMCOHORT (sb) ;
REMCOHORT (svb) ;
REMCOHORT (excb) ;
